#+TITLE: 2021 challenge
#+AUTHOR: Advent of code
#+EMAIL: nazar@autistici.org
#+LANGUAGE: en
#+OPTIONS: toc:nil
* DONE Day 1.1

You're minding your  own business on a ship at  sea when the overboard
alarm goes off!  You rush to see  if you can help.  Apparently, one of
the Elves  tripped and accidentally  sent the sleigh keys  flying into
the ocean!

Before you know it, you're inside a submarine the Elves keep ready for
situations like  this. It's  covered in  Christmas lights  (because of
course it is), and it even  has an experimental antenna that should be
able  to track  the keys  if you  can boost  its signal  strength high
enough; there's  a little  meter that  indicates the  antenna's signal
strength by displaying 0-50 stars.

Your instincts tell  you that in order to save  Christmas, you'll need
to get all fifty stars by December 25th.

Collect stars by  solving puzzles. Two puzzles will  be made available
on each day in the Advent calendar; the second puzzle is unlocked when
you complete the first. Each puzzle grants one star. Good luck!

As  the   submarine  drops  below   the  surface  of  the   ocean,  it
automatically performs  a sonar sweep  of the  nearby sea floor.  On a
small screen, the sonar sweep report (your puzzle input) appears: each
line  is a  measurement of  the  sea floor  depth as  the sweep  looks
further and further away from the submarine.

For example, suppose you had the following report:
#+begin_example
199
200
208
210
200
207
240
269
260
263
#+end_example

This report indicates  that, scanning outward from  the submarine, the
sonar sweep found depths of 199, 200, 208, 210, and so on.

The first  order of business  is to figure  out how quickly  the depth
increases, just so you know what  you're dealing with - you never know
if the keys will get carried into  deeper water by an ocean current or
a fish or something.

To do  this, count the number  of times a depth  measurement increases
from the  previous measurement.  (There is  no measurement  before the
first measurement.) In the example above, the changes are as follows:

#+begin_example
199 (N/A - no previous measurement)
200 (increased)
208 (increased)
210 (increased)
200 (decreased)
207 (increased)
240 (increased)
269 (increased)
260 (decreased)
263 (increased)
#+end_example

In this example, there are 7 measurements that are larger than the
previous measurement.

How many measurements are larger than the previous measurement?

#+begin_src fennel :session day01 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve [lines]
  (let [t (aoc.table-zip
           (aoc.table-range lines 1 (- (length lines) 1))
           (aoc.table-range lines 2 (length lines)))]
    (lume.filter t (fn [[f t]] (< (tonumber f) (tonumber t))))))

(fn test [expected input]
  (assert (= expected (length (solve input)))))

(local test-input ["199"
                   "200"
                   "208"
                   "210"
                   "200"
                   "207"
                   "240"
                   "269"
                   "260"
                   "263"])

(test 7 test-input)

(fn real [input]
  (length (solve input)))

(real (aoc.string-from "2021/01.inp"))
#+end_src

#+RESULTS:
: 1400


* DONE Day 1.2

Considering every single measurement isn't as useful as you expected:
there's just too much noise in the data.

Instead, consider sums of a three-measurement sliding window. Again
considering the above example:

#+begin_example
199  A      
200  A B    
208  A B C  
210    B C D
200  E   C D
207  E F   D
240  E F G  
269    F G H
260      G H
263        H
#+end_example

Start by comparing the first and second three-measurement windows. The
measurements in the first window are marked A (199, 200, 208); their
sum is 199 + 200 + 208 = 607. The second window is marked B (200, 208,
210); its sum is 618. The sum of measurements in the second window is
larger than the sum of the first, so this first comparison increased.

Your goal now is to count the  number of times the sum of measurements
in this sliding window increases from  the previous sum. So, compare A
with B,  then compare B with  C, then C with  D, and so on.  Stop when
there   aren't   enough   measurements    left   to   create   a   new
three-measurement sum.

In the above example, the sum of each three-measurement window is as
follows:

#+begin_example
A: 607 (N/A - no previous sum)
B: 618 (increased)
C: 618 (no change)
D: 617 (decreased)
E: 647 (increased)
F: 716 (increased)
G: 769 (increased)
H: 792 (increased)
#+end_example

In this example, there are 5 sums that are larger than the previous
sum.

Consider sums of a three-measurement sliding window. How many sums are
larger than the previous sum?

#+begin_src fennel :session day01 :exports both
(fn solve2 [lines]
  (let [res []]
    (for [i 3 (length lines)]
      (table.insert res (+ (. lines (- i 2))
                           (. lines (- i 1))
                           (. lines i))))
    (solve res)))

(fn test2 [expected input]
  (assert (= expected (length (solve2 input)))))

(test2 5 test-input)

(fn real2 [input]
  (length (solve2 input)))

(real2 (aoc.string-from "2021/01.inp"))
#+end_src

#+RESULTS:
: 1429


* DONE Day 2.1

Now, you need to figure out how to pilot this thing.

It seems like the submarine can take a series of commands like forward
1, down 2, or up 3:
- forward X increases the horizontal position by X units.
- down X increases the depth by X units.
- up X decreases the depth by X units.

Note that since you're on a submarine, down and up affect your depth,
and so they have the opposite result of what you might expect.

The submarine seems to already have a planned course (your puzzle
input). You should probably figure out where it's going. For example:

#+begin_example
forward 5
down 5
forward 8
up 3
down 8
forward 2
#+end_example

Your horizontal position and depth both start at 0. The steps above
would then modify them as follows:
- forward 5 adds 5 to your horizontal position, a total of 5.
- down 5 adds 5 to your depth, resulting in a value of 5.
- forward 8 adds 8 to your horizontal position, a total of 13.
- up 3 decreases your depth by 3, resulting in a value of 2.
- down 8 adds 8 to your depth, resulting in a value of 10.
- forward 2 adds 2 to your horizontal position, a total of 15.

After  following  these  instructions,  you would  have  a  horizontal
position of 15 and a depth of 10. (Multiplying these together produces
150.)

Calculate  the horizontal  position  and depth  you  would have  after
following the  planned course. What  do you  get if you  multiply your
final horizontal position by your final depth?

#+begin_src fennel :session day02 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve [lines]
  (let [s {:x 0 :y 0}]
    (each [_ line (ipairs lines)]
      (case (aoc.string-split line " ")
        ["forward" f] (tset s :x (+ f (. s :x)))
        ["down" d] (tset s :y (+ d (. s :y)))
        ["up" u] (tset s :y (- (. s :y) u))))
    (* (. s :x) (. s :y))))

(fn test [expected input]
  (assert (= expected (solve input))))

(local test-input ["forward 5"
                   "down 5"
                   "forward 8"
                   "up 3"
                   "down 8"
                   "forward 2"])

(test 150 test-input)

(fn real [input]
  (solve input))

(real (aoc.string-from "2021/02.inp"))
#+end_src

#+RESULTS:
: 1561344


* DONE Day 2.2

Based on  your calculations, the  planned course doesn't seem  to make
any sense. You find the submarine manual and discover that the process
is actually slightly more complicated.

In  addition to  horizontal position  and depth,  you'll also  need to
track a  third value, aim, which  also starts at 0.  The commands also
mean something entirely different than you first thought:
- down X increases your aim by X units.
- up X decreases your aim by X units.
- forward X does two things:
  - It increases your horizontal position by X units.
  - It increases your depth by your aim multiplied by X.

Again  note that  since you're  on  a submarine,  down and  up do  the
opposite of what you might expect: "down" means aiming in the positive
direction.

Now, the above example does something different:
- forward 5 adds 5 to your horizontal position, a total of 5. Because
  your aim is 0, your depth does not change.
- down 5 adds 5 to your aim, resulting in a value of 5.
- forward 8 adds 8 to your horizontal position, a total of 13. Because
  your aim is 5, your depth increases by 8*5=40.
- up 3 decreases your aim by 3, resulting in a value of 2.
- down 8 adds 8 to your aim, resulting in a value of 10.
- forward 2 adds 2 to your horizontal position, a total of 15. Because
  your aim is 10, your depth increases by 2*10=20 to a total of 60.
  
After following  these new instructions,  you would have  a horizontal
position of 15 and a depth of 60. (Multiplying these produces 900.)

Using  this   new  interpretation  of  the   commands,  calculate  the
horizontal  position and  depth  you would  have  after following  the
planned course. What do you get  if you multiply your final horizontal
position by your final depth?

#+begin_src fennel :session day02 :exports both
(fn solve2 [lines]
  (let [s {:x 0 :y 0 :z 0}]
    (each [_ line (ipairs lines)]
      (case (aoc.string-split line " ")
        ["forward" f] (do
                        (tset s :y (+ (. s :y) (* (. s :z) f)))
                        (tset s :x (+ f (. s :x))))
        ["down" d] (tset s :z (+ d (. s :z)))
        ["up" u] (tset s :z (- (. s :z) u))))
    (* (. s :x) (. s :y))))

(fn test2 [expected input]
  (let [res (solve2 input)]
    (assert (= expected res) res)))

(test2 900 test-input)

(fn real2 [input]
  (solve2 input))

(real2 (aoc.string-from "2021/02.inp"))
#+end_src

#+RESULTS:
: 1848454425


* DONE Day 3.1

The submarine has been making some  odd creaking noises, so you ask it
to produce a diagnostic report just in case.

The diagnostic report (your puzzle input) consists of a list of binary
numbers which, when decoded properly,  can tell you many useful things
about the conditions of the submarine. The first parameter to check is
the power consumption.

You  need to  use  the  binary numbers  in  the  diagnostic report  to
generate two new binary numbers (called the gamma rate and the epsilon
rate).  The power  consumption can  then be  found by  multiplying the
gamma rate by the epsilon rate.

Each  bit in  the gamma  rate can  be determined  by finding  the most
common  bit  in the  corresponding  position  of  all numbers  in  the
diagnostic report. For example, given the following diagnostic report:

#+begin_example
00100
11110
10110
10111
10101
01111
00111
11100
10000
11001
00010
01010
#+end_example

Considering only the  first bit of each number, there  are five 0 bits
and seven 1 bits. Since the most common bit is 1, the first bit of the
gamma rate is 1.

The most common second bit of  the numbers in the diagnostic report is
0, so the second bit of the gamma rate is 0.

The most common value  of the third, fourth, and fifth  bits are 1, 1,
and 0,  respectively, and so  the final three  bits of the  gamma rate
are 110.

So, the gamma rate is the binary number 10110, or 22 in decimal.

The epsilon rate  is calculated in a similar way;  rather than use the
most common bit, the least common  bit from each position is used. So,
the epsilon rate is 01001, or 9 in decimal. Multiplying the gamma rate
(22) by the epsilon rate (9) produces the power consumption, 198.

Use  the binary  numbers in  your diagnostic  report to  calculate the
gamma rate and epsilon rate, then  multiply them together. What is the
power consumption of the submarine?  (Be sure to represent your answer
in decimal, not binary.)


#+begin_src fennel :session day03 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn read-input [input]
  (aoc.table-transpose
   (lume.map input #(aoc.string-toarray $))))

(fn solve [lines]
  (let [xs (read-input lines)
        gamma []
        epsilon []]
    (each [_ t (ipairs xs)]
      (case (< (aoc.table-count t 1) (aoc.table-count t 0))
        true (do
               (table.insert gamma 0)
               (table.insert epsilon 1))
        false (do
                (table.insert gamma 1)
                (table.insert epsilon 0))))
    (* (aoc.todecimal gamma)
       (aoc.todecimal epsilon))))

(fn test [expected input]
  (let [res (solve input)]
    (assert (= expected res) res)))

(local test-input ["00100"
                   "11110"
                   "10110"
                   "10111"
                   "10101"
                   "01111"
                   "00111"
                   "11100"
                   "10000"
                   "11001"
                   "00010"
                   "01010"])

(test 198 test-input)

(fn real [input]
  (solve input))

(real (aoc.string-from "2021/03.inp"))
#+end_src

#+RESULTS:
: 3009600


* DONE Day 3.2

Next,  you  should  verify  the  life support  rating,  which  can  be
determined  by multiplying  the  oxygen generator  rating  by the  CO2
scrubber rating.

Both  the oxygen  generator rating  and  the CO2  scrubber rating  are
values that can  be found in your diagnostic report  - finding them is
the tricky part. Both values are  located using a similar process that
involves filtering out values until only one remains. Before searching
for either  rating value, start with  the full list of  binary numbers
from your diagnostic  report and consider just the first  bit of those
numbers. Then:
- Keep  only numbers  selected by  the bit  criteria for  the type  of
  rating value for  which you are searching. Discard  numbers which do
  not match the bit criteria.
- If you only have one number left, stop; this is the rating value for
  which you are searching.
- Otherwise,  repeat the  process,  considering the  next  bit to  the
  right.
  
The bit  criteria depends on  which type of  rating value you  want to
find:
- To find oxygen generator rating,  determine the most common value (0
  or 1) in  the current bit position, and keep  only numbers with that
  bit in  that position. If  0 and 1  are equally common,  keep values
  with a 1 in the position being considered.
- To find  CO2 scrubber  rating, determine the  least common  value (0
  or 1) in  the current bit position, and keep  only numbers with that
  bit in  that position. If  0 and 1  are equally common,  keep values
  with a 0 in the position being considered.
  
For example, to determine the  oxygen generator rating value using the
same example diagnostic report from above:
- Start with  all 12 numbers and  consider only the first  bit of each
  number. There are more 1 bits (7)  than 0 bits (5), so keep only the
  7  numbers with  a 1  in the  first position:  11110, 10110,  10111,
  10101, 11100, 10000, and 11001.
- Then, consider the second bit of  the 7 remaining numbers: there are
  more 0 bits (4) than 1 bits (3), so keep only the 4 numbers with a 0
  in the second position: 10110, 10111, 10101, and 10000.
- In the third position,  three of the four numbers have  a 1, so keep
  those three: 10110, 10111, and 10101.
- In the fourth position,  two of the three numbers have  a 1, so keep
  those two: 10110 and 10111.
- In the  fifth position, there  are an equal number  of 0 bits  and 1
  bits (one each).  So, to find the oxygen generator  rating, keep the
  number with a 1 in that position: 10111.
- As there is only one number  left, stop; the oxygen generator rating
  is 10111, or 23 in decimal.
  
Then, to determine the CO2 scrubber rating value from the same example
above:
- Start again with  all 12 numbers and consider only  the first bit of
  each number.  There are fewer  0 bits (5) than  1 bits (7),  so keep
  only the  5 numbers with  a 0 in  the first position:  00100, 01111,
  00111, 00010, and 01010.
- Then, consider the second bit of  the 5 remaining numbers: there are
  fewer 1 bits (2) than 0 bits (3),  so keep only the 2 numbers with a
  1 in the second position: 01111 and 01010.
- In the  third position, there  are an equal number  of 0 bits  and 1
  bits  (one each).  So, to  find the  CO2 scrubber  rating, keep  the
  number with a 0 in that position: 01010.
- As there is  only one number left, stop; the  CO2 scrubber rating is
  01010, or 10 in decimal.
  
Finally,  to  find  the  life  support  rating,  multiply  the  oxygen
generator rating (23) by the CO2 scrubber rating (10) to get 230.

Use  the binary  numbers in  your diagnostic  report to  calculate the
oxygen generator  rating and CO2  scrubber rating, then  multiply them
together. What is  the life support rating of the  submarine? (Be sure
to represent your answer in decimal, not binary.)

#+begin_src fennel :session day03 :exports both
(fn rate-generator [xs pos]
  (if (= 1 (length xs)) (aoc.todecimal (. xs 1))
      (let [bits (. (aoc.table-transpose xs) pos)
            ones (aoc.table-count bits 1)
            zeroes (aoc.table-count bits 0)]
        (var pred "")
        (if (<= zeroes ones)
            (set pred "1")
            (set pred "0"))
        (let [xss (lume.filter xs #(= pred (. $ pos)))]
          (rate-generator xss (+ 1 pos))))))

(fn rate-scrubber [xs pos]
  (if (= 1 (length xs)) (aoc.todecimal (. xs 1))
      (let [bits (. (aoc.table-transpose xs) pos)
            ones (aoc.table-count bits 1)
            zeroes (aoc.table-count bits 0)]
        (var pred "")
        (if (<= zeroes ones)
            (set pred "0")
            (set pred "1"))
        (let [xss (lume.filter xs #(= pred (. $ pos)))]
          (rate-scrubber xss (+ 1 pos))))))

(fn solve2 [lines]
  (let [xs (lume.map lines #(aoc.string-toarray $))
        g (rate-generator xs 1)
        s (rate-scrubber xs 1)]
    (* g s)))

(fn test2 [expected input]
  (let [res (solve2 input)]
    (assert (= expected res) res)))

(test2 230 test-input)

(fn real2 [input]
  (solve2 input))

(real2 (aoc.string-from "2021/03.inp"))
#+end_src

#+RESULTS:
: 6940518

* DONE Day 4.1
You're already almost  1.5km (almost a mile) below the  surface of the
ocean, already so  deep that you can't see any  sunlight. What you can
see, however, is a giant squid that has attached itself to the outside
of your submarine.

Maybe it wants to play bingo?

Bingo is played  on a set of  boards each consisting of a  5x5 grid of
numbers. Numbers are chosen at random, and the chosen number is marked
on all  boards on  which it  appears. (Numbers may  not appear  on all
boards.)  If all  numbers in  any row  or any  column of  a board  are
marked, that board wins. (Diagonals don't count.)


The submarine has a bingo subsystem to help passengers (currently, you
and  the giant  squid) pass  the  time. It  automatically generates  a
random order in which to draw numbers and a random set of boards (your
puzzle input). For example:

#+begin_example
7,4,9,5,11,17,23,2,0,14,21,24,10,16,13,6,15,25,12,22,18,20,8,19,3,26,1

22 13 17 11  0
 8  2 23  4 24
21  9 14 16  7
 6 10  3 18  5
 1 12 20 15 19

 3 15  0  2 22
 9 18 13 17  5
19  8  7 25 23
20 11 10 24  4
14 21 16 12  6

14 21 17 24  4
10 16 15  9 19
18  8 23 26 20
22 11 13  6  5
 2  0 12  3  7
#+end_example

After the first five numbers are drawn (7, 4, 9, 5, and 11), there are
no winners, but the boards are  marked as follows (shown here adjacent
to each other to save space):

#+begin_example
22 13 17 11  0         3 15  0  2 22        14 21 17 24  4
 8  2 23  4 24         9 18 13 17  5        10 16 15  9 19
21  9 14 16  7        19  8  7 25 23        18  8 23 26 20
 6 10  3 18  5        20 11 10 24  4        22 11 13  6  5
 1 12 20 15 19        14 21 16 12  6         2  0 12  3  7
#+end_example

After the next six numbers are drawn (17, 23, 2, 0, 14, and 21), there
are still no winners:

#+begin_example
22 13 17 11  0         3 15  0  2 22        14 21 17 24  4
 8  2 23  4 24         9 18 13 17  5        10 16 15  9 19
21  9 14 16  7        19  8  7 25 23        18  8 23 26 20
 6 10  3 18  5        20 11 10 24  4        22 11 13  6  5
 1 12 20 15 19        14 21 16 12  6         2  0 12  3  7
#+end_example

Finally, 24 is drawn:

#+begin_example
22 13 17 11  0         3 15  0  2 22        14 21 17 24  4
 8  2 23  4 24         9 18 13 17  5        10 16 15  9 19
21  9 14 16  7        19  8  7 25 23        18  8 23 26 20
 6 10  3 18  5        20 11 10 24  4        22 11 13  6  5
 1 12 20 15 19        14 21 16 12  6         2  0 12  3  7
#+end_example

At  this point,  the third  board  wins because  it has  at least  one
complete row or column of marked numbers (in this case, the entire top
row is marked: 14 21 17 24 4).

The score of the winning board can now be calculated. Start by finding
the sum of all  unmarked numbers on that board; in  this case, the sum
is 188.  Then, multiply that  sum by the  number that was  just called
when the board won, 24, to get the final score, 188 * 24 = 4512.

To guarantee victory  against the giant squid, figure  out which board
will  win first.  What will  your final  score be  if you  choose that
board?

#+begin_src fennel :session day04 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["7,4,9,5,11,17,23,2,0,14,21,24,10,16,13,6,15,25,12,22,18,20,8,19,3,26,1"
        ""
        "22 13 17 11  0"
        " 8  2 23  4 24"
        "21  9 14 16  7"
        " 6 10  3 18  5"
        " 1 12 20 15 19"
        ""
        " 3 15  0  2 22"
        " 9 18 13 17  5"
        "19  8  7 25 23"
        "20 11 10 24  4"
        "14 21 16 12  6"
        ""
        "14 21 17 24  4"
        "10 16 15  9 19"
        "18  8 23 26 20"
        "22 11 13  6  5"
        " 2  0 12  3  7"])

(fn read-input [lines]
  (let [res []
        board []
        deal []]
    (each [num line (ipairs lines)]
      (let [digits (aoc.string-tonumarray line)]
        (if (= 1 num) (aoc.table-move 1 digits deal (length digits))
            (= "" line) (let [new []]
                          (when (= 5 (length board))
                            (aoc.table-move 1 board new 5)
                            (table.insert res new)))
            (table.insert board
                          (aoc.string-tonumarray line)))))
    (let [new []]
      (aoc.table-move 1 board new 5)
      (table.insert res new))
    [deal res]))

(fn scan-board [board deal]
  (var bingo false)
  (for [i 1 (length board) &until bingo]
    (when (lume.all (. board i) (fn [e] (aoc.table-contains? deal e)))
      (set bingo i)))
  (if bingo (. board bingo)
      (let [nb (aoc.table-transpose board)]
        (for [i 1 (length nb) &until bingo]
          (when (lume.all (. nb i) (fn [e] (aoc.table-contains? deal e)))
            (set bingo i)))
        (or (?. nb bingo) []))))

(fn score [deal winner]
  (*
   (. deal (length deal))
   (aoc.table-sum-if winner
                 #(not (aoc.table-contains? deal $)))))

(fn find-winner [deal boards]
  (var winner 0)
  (var numbers [])
  (for [i 1 (length deal) &until (not= 0 winner)]
    (each [j board (ipairs boards) &until (not= 0 winner)]
      (let [draw (aoc.table-range deal 1 i)
            bingo (scan-board board draw)]
        (when (not= 0 (length bingo))
          (set winner j)
          (set numbers draw)))))
  [winner numbers])

(fn solve [deal boards]
  (let [[winner numbers] (find-winner deal boards)]
    (score numbers (. boards winner))))

(fn test [expected input]
  (let [[deals boards] (read-input input)
        res (solve deals boards)]
    (assert (= expected res) res)))

(test 4512 test-input)

(fn real [input]
  (let [[deals boards] (read-input input)]
    (solve deals boards)))

(real (aoc.string-from "2021/04.inp"))
#+end_src

#+RESULTS:
: 82440

* DONE Day 4.2
On the other hand,  it might be wise to try  a different strategy: let
the giant squid win.

You aren't  sure how  many bingo  boards a giant  squid could  play at
once, so rather  than waste time counting its arms,  the safe thing to
do  is  to figure  out  which  board will  win  last  and choose  that
one. That way, no matter which boards it picks, it will win for sure.

In  the above  example, the  second board  is the  last to  win, which
happens  after  13 is  eventually  called  and  its middle  column  is
completely marked. If  you were to keep playing until  this point, the
second board would have  a sum of unmarked numbers equal  to 148 for a
final score of 148 * 13 = 1924.

Figure out  which board will  win last. Once  it wins, what  would its
final score be?

#+begin_src fennel :session day04 :exports both
(fn solve2 [deal boards]
  (let [[winner numbers] (find-winner deal boards)]
    (if (= 1 (length boards))
      (score numbers (. boards 1))
      (do
        (table.remove boards winner)
        (solve2 deal boards)))))

(fn test2 [expected input]
  (let [[deals boards] (read-input input)
        res (solve2 deals boards)]
    (assert (= expected res) res)))

(test2 1924 test-input)

(fn real2 [input]
  (let [[deals boards] (read-input input)]
    (solve2 deals boards)))

(real2 (aoc.string-from "2021/04.inp"))
#+end_src

#+RESULTS:
: 20774

* DONE Day 6.1

The sea floor is getting steeper. Maybe the sleigh keys got carried
this way?

A massive  school of glowing  lanternfish swims past. They  must spawn
quickly to reach such large numbers - maybe exponentially quickly? You
should model their growth rate to be sure.

Although you know nothing about  this specific species of lanternfish,
you make some guesses about their attributes. Surely, each lanternfish
creates a new lanternfish once every 7 days.

However,  this process  isn't necessarily  synchronized between  every
lanternfish - one lanternfish might have  2 days left until it creates
another lanternfish,  while another  might have 4.  So, you  can model
each fish as a single number  that represents the number of days until
it creates a new lanternfish.

Furthermore, you reason, a new  lanternfish would surely need slightly
longer before  it's capable  of producing  more lanternfish:  two more
days for its first cycle.

So, suppose you have a lanternfish with an internal timer value of 3:
- After one day, its internal timer would become 2.
- After another day, its internal timer would become 1.
- After another day, its internal timer would become 0.
- After another day, its internal timer would reset to 6, and it would
  create a new lanternfish with an internal timer of 8.
- After another day, the first lanternfish would have an internal
  timer of 5, and the second lanternfish would have an internal timer
  of 7.
  
A lanternfish  that creates a  new fish resets its  timer to 6,  not 7
(because 0  is included as a  valid timer value). The  new lanternfish
starts with  an internal timer of  8 and does not  start counting down
until the next day.

Realizing  what  you're  trying  to do,  the  submarine  automatically
produces  a list  of the  ages of  several hundred  nearby lanternfish
(your puzzle input). For example, suppose you were given the following
list:

#+begin_example
3,4,3,1,2
#+end_example

This list means  that the first fish  has an internal timer  of 3, the
second fish  has an  internal timer of  4, and so  on until  the fifth
fish, which  has an internal  timer of  2. Simulating these  fish over
several days would proceed as follows:

#+begin_example
Initial state: 3,4,3,1,2
After  1 day:  2,3,2,0,1
After  2 days: 1,2,1,6,0,8
After  3 days: 0,1,0,5,6,7,8
After  4 days: 6,0,6,4,5,6,7,8,8
After  5 days: 5,6,5,3,4,5,6,7,7,8
After  6 days: 4,5,4,2,3,4,5,6,6,7
After  7 days: 3,4,3,1,2,3,4,5,5,6
After  8 days: 2,3,2,0,1,2,3,4,4,5
After  9 days: 1,2,1,6,0,1,2,3,3,4,8
After 10 days: 0,1,0,5,6,0,1,2,2,3,7,8
After 11 days: 6,0,6,4,5,6,0,1,1,2,6,7,8,8,8
After 12 days: 5,6,5,3,4,5,6,0,0,1,5,6,7,7,7,8,8
After 13 days: 4,5,4,2,3,4,5,6,6,0,4,5,6,6,6,7,7,8,8
After 14 days: 3,4,3,1,2,3,4,5,5,6,3,4,5,5,5,6,6,7,7,8
After 15 days: 2,3,2,0,1,2,3,4,4,5,2,3,4,4,4,5,5,6,6,7
After 16 days: 1,2,1,6,0,1,2,3,3,4,1,2,3,3,3,4,4,5,5,6,8
After 17 days: 0,1,0,5,6,0,1,2,2,3,0,1,2,2,2,3,3,4,4,5,7,8
After 18 days: 6,0,6,4,5,6,0,1,1,2,6,0,1,1,1,2,2,3,3,4,6,7,8,8,8,8
#+end_example

Each day, a 0 becomes a 6 and adds a new 8 to the end of the list,
while each other number decreases by 1 if it was present at the start
of the day.

In this example, after 18 days, there are a total of 26 fish. After 80
days, there would be a total of 5934.

Find a way to simulate lanternfish. How many lanternfish would there
be after 80 days?

#+begin_src fennel :session day06 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input "3,4,3,1,2")

(fn life-cycle [xs]
  (let [result []]
    (each [_ x (ipairs xs)]
      (case x
        0 (do
            (table.insert result 6)
            (table.insert result 8))
        _ (table.insert result (- x 1))))
    result))

(fn solve [input]
  (var res (aoc.string-tonumarray input))
  (for [i 1 80]
    (set res (life-cycle res)))
  (length res))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 5934 test-input)

(fn real [input]
  (solve (. input 1)))

(real (aoc.string-from "2021/06.inp"))
#+end_src

#+RESULTS:
: 354564

* DONE Day 6.2

Suppose  the lanternfish  live  forever and  have  unlimited food  and
space. Would they take over the entire ocean?

After  256 days  in  the example  above,  there would  be  a total  of
26984457539 lanternfish! How many lanternfish would there be after 256
days?

#+begin_src fennel  :session day06 :exports both
(fn read-input [input]
  (let [population [0 0 0 0 0 0 0 0 0]]
    (icollect [_ x (ipairs (aoc.string-tonumarray input))]
      (tset population (+ 1 x) (+ 1 (. population (+ 1 x)))))
    population))

(fn life-cycle2 [xs]
  [(. xs 2)
   (. xs 3)
   (. xs 4)
   (. xs 5)
   (. xs 6)
   (. xs 7)
   (+ (. xs 8) (. xs 1))
   (. xs 9)
   (. xs 1)])

(fn solve2 [input cycles]
  (if (= 0 cycles) input
      (solve2 (life-cycle2 input) (- cycles 1))))

(fn test2 [expected input cycles]
  (let [population (read-input input)
        result (aoc.table-sum (solve2 population cycles))]
    (assert (= expected result) result)))

(test2 5934 test-input 80)

(test2 26984457539 test-input 256)

(fn real2 [input]
  (aoc.table-sum (solve2 (read-input (. input 1)) 256)))

(real2 (aoc.string-from "2021/06.inp"))
#+end_src

#+RESULTS:
: 1609058859115

* DONE Day 7.1
A giant  whale has decided your  submarine is its next  meal, and it's
much faster than you are. There's nowhere to run!

Suddenly, a swarm of crabs (each in  its own tiny submarine - it's too
deep  for them  otherwise) zooms  in to  rescue you!  They seem  to be
preparing  to blast  a hole  in the  ocean floor;  sensors indicate  a
massive underground cave system just beyond where they're aiming!

The crab submarines all need to  be aligned before they'll have enough
power  to  blast  a  large  enough hole  for  your  submarine  to  get
through. However, it  doesn't look like they'll be  aligned before the
whale catches you! Maybe you can help?

There's one major catch - crab submarines can only move horizontally.

You quickly make a list of  the horizontal position of each crab (your
puzzle input). Crab submarines have limited  fuel, so you need to find
a way to make all of  their horizontal positions match while requiring
them to spend as little fuel as possible.

For example, consider the following horizontal positions:

#+begin_example
16,1,2,0,4,2,7,1,2,14
#+end_example

This means  there's a crab  with horizontal  position 16, a  crab with
horizontal position 1, and so on.

Each change of 1 step in horizontal  position of a single crab costs 1
fuel. You could  choose any horizontal position to align  them all on,
but the one that costs the least fuel is horizontal position 2:
- Move from 16 to 2: 14 fuel
- Move from 1 to 2: 1 fuel
- Move from 2 to 2: 0 fuel
- Move from 0 to 2: 2 fuel
- Move from 4 to 2: 2 fuel
- Move from 2 to 2: 0 fuel
- Move from 7 to 2: 5 fuel
- Move from 1 to 2: 1 fuel
- Move from 2 to 2: 0 fuel
- Move from 14 to 2: 12 fuel

This costs a total of 37  fuel. This is the cheapest possible outcome;
more  expensive outcomes  include aligning  at position  1 (41  fuel),
position 3 (39 fuel), or position 10 (71 fuel).

Determine the horizontal position that the crabs can align to using
the least fuel possible. How much fuel must they spend to align to
that position?

#+begin_src fennel :session day07 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input "16,1,2,0,4,2,7,1,2,14")

(fn even? [x]
  (= 0 (% x 2)))

(fn median [xs]
  (table.sort xs)
  (let [len (length xs)
        mid (aoc.int/ len 2)]
    (if (even? len)
        (/ (+ (. xs mid) (. xs (aoc.inc mid))) 2)
        (. xs (+ 1 mid)))))

(fn solve [input]
  (let [in (aoc.string-tonumarray input)
        med (median in)]
    (aoc.table-sum
     (icollect [_ v (ipairs in)]
       (math.abs (- med v))))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 37 test-input)

(fn real [input]
  (solve (. input 1)))

(real (aoc.string-from "2021/07.inp"))
#+end_src

#+RESULTS:
: 336131

* DONE Day 7.2
The crabs don't seem interested in your proposed solution. Perhaps you
misunderstand crab engineering?

As it turns out, crab submarine  engines don't burn fuel at a constant
rate. Instead,  each change of 1  step in horizontal position  costs 1
more unit of  fuel than the last:  the first step costs  1, the second
step costs 2, the third step costs 3, and so on.

As  each  crab moves,  moving  further  becomes more  expensive.  This
changes the  best horizontal  position to  align them  all on;  in the
example above, this becomes 5:

- Move from 16 to 5: 66 fuel
- Move from 1 to 5: 10 fuel
- Move from 2 to 5: 6 fuel
- Move from 0 to 5: 15 fuel
- Move from 4 to 5: 1 fuel
- Move from 2 to 5: 6 fuel
- Move from 7 to 5: 3 fuel
- Move from 1 to 5: 10 fuel
- Move from 2 to 5: 6 fuel
- Move from 14 to 5: 45 fuel

This costs  a total  of 170  fuel. This is  the new  cheapest possible
outcome; the old alignment position (2) now costs 206 fuel instead.

Determine the  horizontal position that  the crabs can align  to using
the least fuel possible so they can make you an escape route! How much
fuel must they spend to align to that position?

#+begin_src fennel :session day07 :exports both
(fn mean [xs]
  (let [sum (aoc.table-sum xs)
        cnt (length xs)]
    (math.floor (/ sum cnt))))

(fn sum [n]
  (/ (* n (+ 1 n)) 2))

(fn fuel [f t]
  (sum (math.abs (- f t))))

(fn solve2 [input]
  (let [in (aoc.string-tonumarray input)
        med (mean in)]
    (aoc.table-sum 
     (icollect [_ v (ipairs in)]
       (fuel med v)))))

(fn test2 [expected input]
  (let [res (solve2 input)]
    (assert (= expected res) res)))

(test2 170 test-input)

(fn real2 [input]
  (solve2 (. input 1)))

(real2 (aoc.string-from "2021/07.inp"))
#+end_src

#+RESULTS:
: 92676646

* DONE Day 9.1

These caves seem  to be lava tubes. Parts are  even still volcanically
active; small  hydrothermal vents  release smoke  into the  caves that
slowly settles like rain.

If you can model  how the smoke flows through the  caves, you might be
able to  avoid it and  be that much  safer. The submarine  generates a
heightmap  of the  floor  of the  nearby caves  for  you (your  puzzle
input).

Smoke flows to the lowest point of the area it's in. For example,
consider the following heightmap:

#+begin_example
2199943210
3987894921
9856789892
8767896789
9899965678
#+end_example

Each number corresponds to the  height of a particular location, where
9 is the highest and 0 is the lowest a location can be.

Your first  goal is to  find the low points  - the locations  that are
lower than  any of  its adjacent locations.  Most locations  have four
adjacent locations (up, down, left,  and right); locations on the edge
or  corner  of   the  map  have  three  or   two  adjacent  locations,
respectively. (Diagonal locations do not count as adjacent.)

In the above example, there are  four low points, all highlighted: two
are in the first row (a 1 and a 0), one is in the third row (a 5), and
one  is in  the bottom  row (also  a 5).  All other  locations on  the
heightmap  have some  lower  adjacent  location, and  so  are not  low
points.

The risk  level of  a low  point is 1  plus its  height. In  the above
example, the risk levels of the low points are 2, 1, 6, and 6. The sum
of the risk levels of all low points in the heightmap is therefore 15.

Find all of the low points on your heightmap. What is the sum of the
risk levels of all low points on your heightmap?

#+begin_src fennel :session day09 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["2199943210"
                   "3987894921"
                   "9856789892"
                   "8767896789"
                   "9899965678"])

(fn is-low? [xs i j]
  (let [ij (. (. xs i) j)
        lf (or (?. (?. xs i) (- j 1)) 10)
        rg (or (?. (?. xs i) (+ j 1)) 10)
        up (or (?. (?. xs (- i 1)) j) 10)
        dn (or (?. (?. xs (+ i 1)) j) 10)]
    (and
     (< ij up)
     (< ij dn)
     (< ij lf)
     (< ij rg))))

(fn solve [lines]
  (var res 0)
  (let [input (aoc.read-matrix lines true)]
    (for [i 1 (length input)]
      (for [j 1 (length (. input i))]
        (when (is-low? input i j)
          (set res (+ res (+ 1 (. (. input i) j))))))))
  res)

(fn test [expected input]
  (assert (= expected (solve input))))

(test 15 test-input)

(fn real [input]
  (solve input))

(real (aoc.string-from "2021/09.inp"))
#+end_src

#+RESULTS:
: 522

* DONE Day 10.1

You ask the submarine to determine  the best route out of the deep-sea
cave, but it only replies:

Syntax error in navigation subsystem on line: all of them

All of  them?! The damage  is worse than you  thought. You bring  up a
copy of the navigation subsystem (your puzzle input).

The navigation  subsystem syntax is  made of several  lines containing
chunks. There are one or more  chunks on each line, and chunks contain
zero or  more other chunks. Adjacent  chunks are not separated  by any
delimiter; if one chunk stops, the next chunk (if any) can immediately
start. Every chunk must open and close with one of four legal pairs of
matching characters:
- If a chunk opens with (, it must close with ).
- If a chunk opens with [, it must close with ].
- If a chunk opens with {, it must close with }.
- If a chunk opens with <, it must close with >.

So, () is a legal chunk that  contains no other chunks, as is []. More
complex   but  valid   chunks   include   ([]),  {()()()},   <([{}])>,
[<>({}){}[([])<>]], and even (((((((((()))))))))).

Some lines are incomplete, but  others are corrupted. Find and discard
the corrupted lines first.

A  corrupted  line  is  one  where  a  chunk  closes  with  the  wrong
character - that is, where the  characters it opens and closes with do
not form one of the four legal pairs listed above.

Examples of corrupted chunks include (], {()()()>, (((()))}, and
<([]){()}[{}]). Such a chunk can appear anywhere within a line, and
its presence causes the whole line to be considered corrupted.

For example, consider the following navigation subsystem:
#+begin_example
[({(<(())[]>[[{[]{<()<>>
[(()[<>])]({[<{<<[]>>(
{([(<{}[<>[]}>{[]{[(<()>
(((({<>}<{<{<>}{[]{[]{}
[[<[([]))<([[{}[[()]]]
[{[{({}]{}}([{[{{{}}([]
{<[[]]>}<{[{[{[]{()[[[]
[<(<(<(<{}))><([]([]()
<{([([[(<>()){}]>(<<{{
<{([{{}}[<[[[<>{}]]]>[]]
#+end_example

Some of the lines aren't corrupted, just incomplete; you can ignore
these lines for now. The remaining five lines are corrupted:
#+begin_example
{([(<{}[<>[]}>{[]{[(<()> - Expected ], but found } instead.
[[<[([]))<([[{}[ [()]]] - Expected ], but found ) instead.
[{[{({}]{}}([{[{{{}}([] - Expected ), but found ] instead.
[<(<(<(<{}))><([]([]() - Expected >, but found ) instead.
<{([([[(<>()){}]>(<<{{ - Expected ], but found > instead.
#+end_example

Stop at the first incorrect closing character on each corrupted line.

Did you  know that syntax checkers  actually have contests to  see who
can get  the high  score for syntax  errors in a  file? It's  true! To
calculate the  syntax error score for  a line, take the  first illegal
character on the line and look it up in the following table:
- ): 3 points.
- ]: 57 points.
- }: 1197 points.
- >: 25137 points.

In the above example,  an illegal ) was found twice  (2*3 = 6 points),
an illegal ] was  found once (57 points), an illegal  } was found once
(1197 points), and an illegal > was found once (25137 points). So, the
total  syntax error  score for  this file  is 6+57+1197+25137  = 26397
points!

Find  the  first illegal  character  in  each  corrupted line  of  the
navigation subsystem. What  is the total syntax error  score for those
errors?

#+begin_src fennel :session day10 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["[({(<(())[]>[[{[]{<()<>>"
                   "[(()[<>])]({[<{<<[]>>("
                   "{([(<{}[<>[]}>{[]{[(<()>"
                   "(((({<>}<{<{<>}{[]{[]{}"
                   "[[<[([]))<([[{}[[()]]]"
                   "[{[{({}]{}}([{[{{{}}([]" 
                   "{<[[]]>}<{[{[{[]{()[[[]"
                   "[<(<(<(<{}))><([]([]()"
                   "<{([([[(<>()){}]>(<<{{"
                   "<{([{{}}[<[[[<>{}]]]>[]]"])

(fn solve [lines]
  (let [result []]
    (each [_ line (ipairs lines)]
      (let [stack []
            input (aoc.string-toarray line)]
        (var stop false)
        (each [_ chunk (ipairs input) &until stop]
          (case chunk
            "<" (table.insert stack -25137)
            "{" (table.insert stack -1197)
            "[" (table.insert stack -57)
            "(" (table.insert stack -3)
            ">" (when (not= 0 (+ 25137 (table.remove stack)))
                  (table.insert result 25137)
                  (set stop true))
            "}" (when (not= 0 (+ 1197 (table.remove stack)))
                  (table.insert result 1197)
                  (set stop true))
            "]" (when (not= 0 (+ 57 (table.remove stack)))
                  (table.insert result 57)
                  (set stop true))
            ")" (when (not= 0 (+ 3 (table.remove stack)))
                  (table.insert result 3)
                  (set stop true))))))
    (aoc.table-sum result)))

(fn test [expected input]
  (let [res (solve input)]
    (assert (= expected res) res)))

(test 26397 test-input)

(fn real [input]
  (solve input))

(real (aoc.string-from "2021/10.inp"))
#+end_src

#+RESULTS:
: 399153

* DONE Day 10.2
Now, discard the corrupted lines. The remaining lines are incomplete.

Incomplete  lines  don't  have  any incorrect  characters  -  instead,
they're missing  some closing characters  at the  end of the  line. To
repair  the navigation  subsystem, you  just  need to  figure out  the
sequence of  closing characters that  complete all open chunks  in the
line.

You can only use closing characters (),  ], }, or >), and you must add
them in the correct order so that  only legal pairs are formed and all
chunks end up closed.

In the example above, there are five incomplete lines:
#+begin_example
[({(<(())[]>[[{[]{<()<>> - Complete by adding }}]])})].
[(()[<>])]({[<{<<[]>>( - Complete by adding )}>]}).
(((({<>}<{<{<>}{[]{[]{} - Complete by adding }}>}>)))).
{<[[]]>}<{[{[{[]{()[[[] - Complete by adding ]]}}]}]}>.
<{([{{}}[<[[[<>{}]]]>[]] - Complete by adding ])}>.
#+end_example
  
Did you know  that autocomplete tools also have  contests?  It's true!
The  score   is  determined  by  considering   the  completion  string
character-by-character. Start with a total  score of 0. Then, for each
character, multiply the  total score by 5 and then  increase the total
score by  the point  value given  for the  character in  the following
table:
- ): 1 point.
- ]: 2 points.
- }: 3 points.
- >: 4 points.

So,  the last  completion string  above -  ])}> -  would be  scored as
follows:
- Start with a total score of 0.
- Multiply the total score by 5 to get 0, then add the value of ] (2)
  to get a new total score of 2.
- Multiply the total score by 5 to get 10, then add the value of ) (1)
  to get a new total score of 11.
- Multiply the total score by 5 to get 55, then add the value of } (3)
  to get a new total score of 58.
- Multiply the total score by 5 to get 290, then add the value of >
  (4) to get a new total score of 294.
  
The five lines' completion strings have total scores as follows:
#+begin_example
}}]])})] - 288957 total points.
)}>]}) - 5566 total points.
}}>}>)))) - 1480781 total points.
]]}}]}]}> - 995444 total points.
])}> - 294 total points.
#+end_example

Autocomplete tools  are an odd bunch:  the winner is found  by sorting
all of the scores and then taking the middle score. (There will always
be an odd  number of scores to consider.) In  this example, the middle
score is  288957 because there are  the same number of  scores smaller
and larger than it.

Find  the  completion  string  for each  incomplete  line,  score  the
completion strings, and sort the scores. What is the middle score?

#+begin_src fennel :session day10 :exports both
(fn complete [xs]
  (var score 0)
  (each [_ v (ipairs xs)]
    (case v
      -3 (set score (+ (* 5 score) 1))
      -57 (set score (+ (* 5 score) 2))
      -1197 (set score (+ (* 5 score) 3))
      -25137 (set score (+ (* 5 score) 4))))
  score)

(fn solve2 [lines]
  (let [result []]
    (each [_ line (ipairs lines)]
      (let [stack []
            input (aoc.string-toarray line)]
        (var stop false)
        (each [_ chunk (ipairs input) &until stop]
          (case chunk
            "<" (table.insert stack -25137)
            "{" (table.insert stack -1197)
            "[" (table.insert stack -57)
            "(" (table.insert stack -3)
            ">" (when (not= 0 (+ 25137 (table.remove stack)))
                  (set stop true))
            "}" (when (not= 0 (+ 1197 (table.remove stack)))
                  (set stop true))
            "]" (when (not= 0 (+ 57 (table.remove stack)))
                  (set stop true))
            ")" (when (not= 0 (+ 3 (table.remove stack)))
                  (set stop true))))
        (when (not stop)
          (table.insert result (complete (aoc.table-reverse stack))))))
    (table.sort result)
    (let [mid (+ 1 (aoc.int/ (length result) 2))]
      (. result mid))))

(fn test2 [expected input]
  (let [res (solve2 input)]
    (assert (= expected res) res)))

(test2 288957 test-input)

(fn real2 [input]
  (solve2 input))

(real2 (aoc.string-from "2021/10.inp"))
#+end_src

#+RESULTS:
: 2995077699
