#+TITLE: 2017 challenge
#+AUTHOR: Advent of code
#+EMAIL: nazar@autistici.org
#+LANGUAGE: en
#+OPTIONS: toc:nil

* DONE Day 1.1

The  night before  Christmas,  one of  Santa's Elves  calls  you in  a
panic.  "The printer's  broken! We  can't  print the  Naughty or  Nice
List!" By the  time you make it  to sub-basement 17, there  are only a
few minutes until midnight. "We have  a big problem," she says; "there
must be almost  fifty bugs in this system, but  nothing else can print
The List. Stand in this square,  quick! There's no time to explain; if
you can convince  them to pay you  in stars, you'll be  able to--" She
pulls a lever and the world goes blurry.

When your eyes can focus again,  everything seems a lot more pixelated
than before. She must have sent you inside the computer! You check the
system clock: 25 milliseconds until midnight. With that much time, you
should be able to collect all fifty stars by December 25th.

Collect stars by  solving puzzles. Two puzzles will  be made available
on each day  millisecond in the Advent calendar; the  second puzzle is
unlocked  when  you  complete  the   first.  Each  puzzle  grants  one
star. Good luck!

You're standing  in a room  with "digitization quarantine"  written in
LEDs along one wall. The only door  is locked, but it includes a small
interface. "Restricted Area - Strictly No Digitized Users Allowed."

It goes on to explain that you  may only leave by solving a captcha to
prove you're not a human. Apparently,  you only get one millisecond to
solve the  captcha: too  fast for  a normal human,  but it  feels like
hours to you.

The captcha requires  you to review a sequence of  digits (your puzzle
input) and find the sum of all digits that match the next digit in the
list. The list is  circular, so the digit after the  last digit is the
first digit in the list.

For example:
- 1122 produces a sum of 3 (1 + 2) because the first digit (1) matches
  the second digit and the third digit (2) matches the fourth digit.
- 1111 produces 4 because each digit (all 1) matches the next.
- 1234 produces 0 because no digit matches the next.
- 91212129 produces 9 because the only digit that matches the next one
  is the last digit, 9.
  
What is the solution to your captcha?

#+begin_src fennel :session day01 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(fn solve [input]
  (-> (. input 1)
      (.. (string.sub (. input 1) 1 1))
      (aoc.string-toarray)
      (lume.map (fn [e] (tonumber e)))
      (aoc.partition1)
      (lume.map (fn [[e1 e2]] (if (= e1 e2) e1 0)))
      (aoc.table-sum)))

(fn test [expected input]
  (let [res (solve input)]
    (assert (= expected res) res)))

(test 3 ["1122"])
(test 4 ["1111"])
(test 0 ["1234"])
(test 9 ["91212129"])
(solve (aoc.string-from "2017/01.inp"))
#+end_src

#+RESULTS:
: 995

* DONE Day 1.2

You notice  a progress bar  that jumps to 50%  completion. Apparently,
the  door   isn't  yet  satisfied,   but  it   did  emit  a   star  as
encouragement. The instructions change:

Now, instead of  considering the next digit, it wants  you to consider
the digit  halfway around  the circular  list. That  is, if  your list
contains 10 items, only include a digit  in your sum if the digit 10/2
=  5 steps  forward matches  it. Fortunately,  your list  has an  even
number of elements.

For example:
- 1212 produces  6: the  list contains  4 items,  and all  four digits
  match the digit 2 items ahead.
- 1221 produces 0, because every comparison is between a 1 and a 2.
- 123425 produces  4, because both 2s  match each other, but  no other
  digit has a match.
- 123123 produces 12.
- 12131415 produces 4.

What is the solution to your new captcha?

#+begin_src fennel :session day01 :exports both
(fn solve2 [input]
  (let [xs (lume.map (aoc.string-toarray (. input 1)) #(tonumber $))]
    (aoc.table-sum
     (icollect [i v (ipairs xs)]
        (if (= v (. xs (aoc.modulo+ i (/ (# xs) 2) (# xs)))) v 0)))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 6 ["1212"])
(test2 0 ["1221"])
(test2 4 ["123425"])
(test2 12 ["123123"])
(test2 4 ["12131415"])
(solve2 (aoc.string-from "2017/01.inp"))
#+end_src

#+RESULTS:
: 1130


* DONE Day 2.1

As you walk  through the door, a glowing humanoid  shape yells in your
direction. "You  there! Your state  appears to  be idle. Come  help us
repair  the  corruption in  this  spreadsheet  -  if we  take  another
millisecond, we'll have to display an hourglass cursor!"

The spreadsheet consists of rows of apparently-random numbers. To make
sure the  recovery process  is on  the right track,  they need  you to
calculate  the spreadsheet's  checksum.  For each  row, determine  the
difference  between the  largest  value and  the  smallest value;  the
checksum is the sum of all of these differences.

For example, given the following spreadsheet:
#+begin_example
5 1 9 5
7 5 3
2 4 6 8
#+end_example

- The first row's largest and smallest values are 9 and 1, and their
  difference is 8.
- The second row's largest and smallest values are 7 and 3, and their
  difference is 4.
- The third row's difference is 6.

In this example, the spreadsheet's checksum would be 8 + 4 + 6 = 18.

What is the checksum for the spreadsheet in your puzzle input?


#+begin_src fennel :session day02 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["5\t1\t9\t5"
        "7\t5\t3"
        "2\t4\t6\t8"])

(fn solve [input]
  (let [xs (lume.map input #(aoc.string-tonumarray $))
        ys (icollect [k v (ipairs xs)]
             (- (aoc.max v) (aoc.min v)))]
    (accumulate [sum 0 k v (ipairs ys)]
      (+ sum v))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 18 test-input)

(solve (aoc.string-from "2017/02.inp"))
#+end_src

#+RESULTS:
: 42299

* DONE Day 2.2

"Great work; looks  like we're on the right track  after all. Here's a
star  for   your  effort."  However,   the  program  seems   a  little
worried. Can programs be worried?


"Based on what we're seeing, it looks like all the User wanted is some
information    about   the    =evenly   divisible    values=   in    the
spreadsheet. Unfortunately, none  of us are equipped for  that kind of
calculation - most of us specialize in bitwise operations."

It sounds like  the goal is to  find the only two numbers  in each row
where one evenly divides the other -  that is, where the result of the
division operation  is a  whole number.  They would  like you  to find
those  numbers on  each  line, divide  them, and  add  up each  line's
result.

For example, given the following spreadsheet:

#+begin_example
5 9 2 8
9 4 7 3
3 8 6 5
#+end_example

- In the first row, the only two numbers that evenly divide are 8 and
  2; the result of this division is 4.
- In the second row, the two numbers are 9 and 3; the result is 3.
- In the third row, the result is 2.

In this example, the sum of the results would be =4 + 3 + 2 = 9=.

What is the sum of each row's result in your puzzle input?

#+begin_src fennel :session day02 :exports both
(local test2-input
       ["5\t9\t2\t8"
        "9\t4\t7\t3"
        "3\t8\t6\t5"])

(fn even-division [xs]
  (let [res []]
    (for [i 1 (- (# xs) 1)]
      (for [j (+ i 1) (# xs)]
        (table.insert res 
                      (if (= 0 (% (. xs i) (. xs j)))
                          (/ (. xs i) (. xs j))
                          (= 0 (% (. xs j) (. xs i)))
                          (/ (. xs j) (. xs i))
                          0))))
    res))

(fn solve2 [input]
  (-> input
      (lume.map #(aoc.string-tonumarray $))
      (lume.map #(even-division $))
      (aoc.table-sum)))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 9 test2-input)

(solve2 (aoc.string-from "2017/02.inp"))
#+end_src

#+RESULTS:
: 277


* DONE Day 4.1

A new system  policy has been put in place  that requires all accounts
to  use  a passphrase  instead  of  simply  a password.  A  passphrase
consists of a series of words (lowercase letters) separated by spaces.

To ensure security, a valid passphrase must contain no duplicate words.

For example:
- aa bb cc dd ee is valid.
- aa bb cc dd aa is not valid - the word aa appears more than once.
- aa bb cc dd aaa is valid - aa and aaa count as different words.

The  system's  full  passphrase  list  is  available  as  your  puzzle
input. How many passphrases are valid?

#+begin_src fennel :session day04 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["aa bb cc dd ee"
        "aa bb cc dd aa"
        "aa bb cc dd aaa"])

(fn string-dup? [line]
  (table.sort line)
  (var res true)
  (let [tokens (aoc.partition1 line)]
    (each [_ token (ipairs tokens)]
      (when (= (. token 1) (. token 2))
        (set res false))))
  res)

(fn solve [input]
  (var res 0)
  (let [lines (lume.map input #(aoc.string-split $ " "))]
    (each [_ line (ipairs lines)]
      (when (string-dup? line)
        (set res (+ 1 res)))))
  res)

(fn test [expected input]
  (assert (= expected (solve input))))

(test 2 test-input)

(solve (aoc.string-from "2017/04.inp"))
#+end_src

#+RESULTS:
: 455

* TODO Day 4.2

For  added  security,  yet  another  system policy  has  been  put  in
place. Now,  a valid  passphrase must  contain no  two words  that are
anagrams  of each  other -  that is,  a passphrase  is invalid  if any
word's  letters can  be  rearranged  to form  any  other  word in  the
passphrase.

For example:
- abcde fghij is a valid passphrase.
- abcde xyz ecdab is  not valid - the letters from  the third word can
  be rearranged to form the first word.
- a ab abc abd abf abj is a valid passphrase, because all letters need
  to be used when forming another word.
- iiii oiii ooii oooi oooo is valid.
- oiii  ioii iioi  iiio is  not  valid -  any  of these  words can  be
  rearranged to form any other word.
  
Under this new system policy, how many passphrases are valid?

#+begin_src fennel :session day04 :exports both
(local test2-input
       ["abcde fghij"
        "abcde xyz ecdab"
        "a ab abc abd abf abj"
        "iiii oiii ooii oooi oooo"
        "oiii  ioii iioi  iiio"])

(fn solve2 [input]
  (var res 0)
  (let [lines (lume.map input (fn [line] (aoc.string-split line " ")))
        lines2 (lume.map lines
                         (fn [line] (lume.map line
                                              (fn [word]
                                                (let [t (aoc.string-toarray word)]
                                                  (table.sort t)
                                                  (table.concat t ""))))))]
    (each [_ line (ipairs lines2)]
      (when (string-dup? line)
        (set res (+ 1 res)))))
  res)

(solve2 test2-input)

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 3 test2-input)

(solve2 (aoc.string-from "2017/04.inp"))
#+end_src

#+RESULTS:
: 186
