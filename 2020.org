#+TITLE: 2020 challenge
#+AUTHOR: Advent of code
#+EMAIL: nazar@autistici.org
#+LANGUAGE: en
#+OPTIONS: toc:nil
* DONE Day 1.1

After saving Christmas  five years in a row, you've  decided to take a
vacation at a nice resort on a tropical island. Surely, Christmas will
go on without you.

The   tropical  island   has  its   own  currency   and  is   entirely
cash-only.  The gold  coins  used there  have a  little  picture of  a
starfish;  the locals  just  call  them stars.  None  of the  currency
exchanges seem to have heard of them, but somehow, you'll need to find
fifty of these coins by the time you arrive so you can pay the deposit
on your room.

To save  your vacation, you  need to get  all fifty stars  by December
25th.

Collect stars by  solving puzzles. Two puzzles will  be made available
on each day in the Advent calendar; the second puzzle is unlocked when
you complete the first. Each puzzle grants one star. Good luck!

Before you  leave, the Elves in  accounting just need you  to fix your
expense report (your puzzle  input); apparently, something isn't quite
adding up.

Specifically, they need  you to find the two entries  that sum to 2020
and then multiply those two numbers together.

For example, suppose your expense report contained the following:
#+begin_example
1721
979
366
299
675
1456
#+end_example

In  this   list,  the  two   entries  that   sum  to  2020   are  1721
and 299.  Multiplying them together produces  1721 * 299 =  514579, so
the correct answer is 514579.

Of course,  your expense report is  much larger. Find the  two entries
that sum to 2020; what do you get if you multiply them together?

#+begin_src fennel :session day01 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(local test-input ["1721" "979" "366" "299" "675" "1456"])

(fn solve [input]
  (let [xx (tonumber (aoc.first input))
        xs (aoc.rest input)
        res (lume.filter xs (fn [a] (= 2020 (+ (tonumber a) xx))))]
    (if (aoc.empty? res)
        (solve xs)
        (* xx (tonumber (. res 1))))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 514579 test-input)

(solve (aoc.string-from "2020/01.inp"))
#+end_src

#+RESULTS:
: 63616

* DONE Day 1.2

The Elves in  accounting are thankful for your help;  one of them even
offers  you  a   starfish  coin  they  had  left  over   from  a  past
vacation. They offer you a second one if you can find three numbers in
your expense report that meet the same criteria.

Using the above example again, the  three entries that sum to 2020 are
979,   366,  and   675.   Multiplying  them   together  produces   the
answer, 241861950.

In your expense report, what is  the product of the three entries that
sum to 2020?

#+begin_src fennel :session day01 :exports both
(fn solve2 [input]
  (var res nil)
  (for [i 1 (length input) &until res]
    (for [j i (length input) &until res]
      (for [k j (length input) &until res]
        (let [ii (tonumber (. input i))
              jj (tonumber (. input j))
              kk (tonumber (. input k))]
          (when (= 2020 (+ ii jj kk))
            (set res (* ii jj kk)))))))
  res)

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 241861950 test-input)

(solve2 (aoc.string-from "2020/01.inp"))
#+end_src

#+RESULTS:
: 67877784

* DONE Day 2.1

Your  flight departs  in  a few  days from  the  coastal airport;  the
easiest way down to the coast from here is via toboggan.

The shopkeeper at the North Pole  Toboggan Rental Shop is having a bad
day. "Something's wrong with our computers;  we can't log in!" You ask
if you can take a look.

Their password  database seems to be  a little corrupted: some  of the
passwords  wouldn't  have  been   allowed  by  the  Official  Toboggan
Corporate Policy that was in effect when they were chosen.

To try  to debug the  problem, they have  created a list  (your puzzle
input)  of passwords  (according to  the corrupted  database) and  the
corporate policy when that password was set.

For example, suppose you have the following list:

#+begin_example
1-3 a: abcde
1-3 b: cdefg
2-9 c: ccccccccc
#+end_example

Each  line  gives the  password  policy  and  then the  password.  The
password policy  indicates the  lowest and highest  number of  times a
given letter  must appear for the  password to be valid.  For example,
1-3 a means  that the password must  contain a at least 1  time and at
most 3 times.

In  the above  example, 2  passwords are  valid. The  middle password,
cdefg,  is  not;  it  contains  no   instances  of  b,  but  needs  at
least 1. The  first and third passwords are valid:  they contain one a
or nine c, both within the limits of their respective policies.

How many passwords are valid according to their policies?

#+begin_src fennel :session day02 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(local test-input ["1-3 a: abcde"
                   "1-3 b: cdefg"
                   "2-9 c: ccccccccc"])

(fn read-policy [line]
  (let [tokens (aoc.string-split line " ")
        [min max] (aoc.string-split (. tokens 1) "-")
        val (string.sub (. tokens 2) 1 -2)
        pass (. tokens 3)]
    {:min (tonumber min) :max (tonumber max) :val val :pass pass}))

(fn validate-policy [p]
  (var res 0)
  (each [_ v (ipairs (aoc.string-toarray (. p :pass)))]
    (when (= v (. p :val))
        (set res (+ 1 res))))
  (if (and (<= (. p :min) res)
       (<= res (. p :max)))
      1
      0))

(fn solve [input]
  (var count 0)
  (each [_ line (ipairs input)]
    (set count (+ count
                  (validate-policy (read-policy line)))))
  count)

(fn test [expected input]
  (assert (= expected (solve input))))

(test 2 test-input)

(solve (aoc.string-from "2020/02.inp"))
#+end_src

#+RESULTS:
: 600

* DONE Day 2.2

While it  appears you  validated the  passwords correctly,  they don't
seem to be what the  Official Toboggan Corporate Authentication System
is expecting.

The shopkeeper  suddenly realizes that he  just accidentally explained
the password  policy rules from his  old job at the  sled rental place
down the street! The Official Toboggan Corporate Policy actually works
a little differently.

Each policy actually describes two  positions in the password, where 1
means  the first  character,  2  means the  second  character, and  so
on. (Be careful; Toboggan Corporate Policies have no concept of "index
zero"!)  Exactly  one  of  these  positions  must  contain  the  given
letter.  Other  occurrences  of  the letter  are  irrelevant  for  the
purposes of policy enforcement.

Given the same example list from above:
#+begin_example
1-3 a: abcde is valid: position 1 contains a and position 3 does not.
1-3 b: cdefg is invalid: neither position 1 nor position 3 contains b.
2-9 c: ccccccccc is invalid: both position 2 and position 9 contain c.
#+end_example

How many passwords are valid according to the new interpretation of
the policies?

#+begin_src fennel :session day02 :exports both
(fn validate-policy2 [p]
  (let [val (. p :val)
        arr (aoc.string-toarray (. p :pass))]
    (if (aoc.xor
         (= val (. arr (. p :min)))
         (= val (. arr (. p :max))))
        1
        0)))

(fn solve2 [input]
  (var count 0)
  (each [_ line (ipairs input)]
    (set count (+ count
                  (validate-policy2 (read-policy line)))))
  count)

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 1 test-input)

(solve2 (aoc.string-from "2020/02.inp"))
#+end_src

#+RESULTS:
: 245

* DONE Day 3.1

With  the toboggan  login problems  resolved, you  set off  toward the
airport. While  travel by toboggan  might be easy, it's  certainly not
safe:  there's  very minimal  steering  and  the  area is  covered  in
trees. You'll need  to see which angles will take  you near the fewest
trees.

Due  to the  local geology,  trees  in this  area only  grow on  exact
integer coordinates in  a grid. You make a map  (your puzzle input) of
the open squares (.) and trees (#) you can see. For example:

#+begin_example
..##.......
#...#...#..
.#....#..#.
..#.#...#.#
.#...##..#.
..#.##.....
.#.#.#....#
.#........#
#.##...#...
#...##....#
.#..#...#.#
#+end_example

These aren't the  only trees, though; due to something  you read about
once involving arboreal genetics and biome stability, the same pattern
repeats to the right many times:

#+begin_example
..##.........##.........##.........##.........##.........##.......  --->
#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..
.#....#..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#.
..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#
.#...##..#..#...##..#..#...##..#..#...##..#..#...##..#..#...##..#.
..#.##.......#.##.......#.##.......#.##.......#.##.......#.##.....  --->
.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#
.#........#.#........#.#........#.#........#.#........#.#........#
#.##...#...#.##...#...#.##...#...#.##...#...#.##...#...#.##...#...
#...##....##...##....##...##....##...##....##...##....##...##....#
.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#  --->
#+end_example

You start on  the open square (.)  in the top-left corner  and need to
reach the bottom (below the bottom-most row on your map).

The toboggan  can only follow a  few specific slopes (you  opted for a
cheaper model  that prefers rational  numbers); start by  counting all
the trees you would encounter for the slope right 3, down 1:

From your starting  position at the top-left, check  the position that
is right 3  and down 1. Then,  check the position that is  right 3 and
down 1 from there, and so on until you go past the bottom of the map.

The locations you'd check in the  above example are marked here with O
where there was an open square and X where there was a tree:

#+begin_example
..##.........##.........##.........##.........##.........##.......  --->
#..O#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..
.#....X..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#.
..#.#...#O#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#
.#...##..#..X...##..#..#...##..#..#...##..#..#...##..#..#...##..#.
..#.##.......#.X#.......#.##.......#.##.......#.##.......#.##.....  --->
.#.#.#....#.#.#.#.O..#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#
.#........#.#........X.#........#.#........#.#........#.#........#
#.##...#...#.##...#...#.X#...#...#.##...#...#.##...#...#.##...#...
#...##....##...##....##...#X....##...##....##...##....##...##....#
.#..#...#.#.#..#...#.#.#..#...X.#.#..#...#.#.#..#...#.#.#..#...#.#  --->
#+end_example

In this example,  traversing the map using this slope  would cause you
to encounter 7 trees.

Starting at the  top-left corner of your map and  following a slope of
right 3 and down 1, how many trees would you encounter?

#+begin_src fennel :session day03 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(local test-input ["..##......."
                   "#...#...#.."
                   ".#....#..#."
                   "..#.#...#.#"
                   ".#...##..#."
                   "..#.##....."
                   ".#.#.#....#"
                   ".#........#"
                   "#.##...#..."
                   "#...##....#"
                   ".#..#...#.#"])

(fn solve [dx dy lines]
  (var posx 1)
  (var posy 1)
  (let [field (aoc.read-matrix lines)
        lenx (length (. field 1))
        leny (length field)
        res []]
    (while (<= posy leny)
      (case (. (. field posy ) posx)
        "." (table.insert res 0)
        "#" (table.insert res 1))
      (set posx (if (>= lenx (+ dx posx))
                    (+ dx posx)
                    (- (+ dx posx) lenx)))
      (set posy (+ dy posy)))
    (aoc.table-sum res)))

(fn test [expected dx dy input]
  (assert (= expected (solve dx dy input))))

(test 7 3 1 test-input)

(solve 3 1 (aoc.string-from "2020/03.inp"))
#+end_src

#+RESULTS:
: 178


* DONE Day 3.2

Time  to check  the rest  of the  slopes -  you need  to minimize  the
probability of a sudden arboreal stop, after all.

Determine the number of trees you  would encounter if, for each of the
following slopes,  you start at  the top-left corner and  traverse the
map all the way to the bottom:
- Right 1, down 1.
- Right 3, down 1. (This is the slope you already checked.)
- Right 5, down 1.
- Right 7, down 1.
- Right 1, down 2.

In  the above  example, these  slopes would  find 2,  7, 3,  4, and  2
tree(s)   respectively;  multiplied   together,   these  produce   the
answer 336.

What  do  you  get  if  you multiply  together  the  number  of  trees
encountered on each of the listed slopes?

#+begin_src fennel :session day03 :exports both
(fn solve2 [lines]
  (let [slopes [[1 1]
                [3 1]
                [5 1]
                [7 1]
                [1 2]]
        res []]
    (each [_ [dx dy] (ipairs slopes)]
      (table.insert res (solve dx dy lines)))
    (aoc.table-prod res)))

(fn test2 [expected lines]
  (assert (= expected (solve2 lines))))

(test2 336 test-input)

(solve2 (aoc.string-from "2020/03.inp"))
#+end_src

#+RESULTS:
: 3492520200
