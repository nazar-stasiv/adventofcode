#+TITLE: 2019 challenge
#+AUTHOR: Advent of code
#+EMAIL: nazar@autistici.org
#+LANGUAGE: en
#+OPTIONS: toc:nil

* DONE Day 1.1

Santa  has become  stranded  at the  edge of  the  Solar System  while
delivering  presents to  other  planets! To  accurately calculate  his
position in space, safely align his warp drive, and return to Earth in
time to  save Christmas, he needs  you to bring him  measurements from
fifty stars.

Collect stars by  solving puzzles. Two puzzles will  be made available
on each day in the Advent calendar; the second puzzle is unlocked when
you complete the first. Each puzzle grants one star. Good luck!

The Elves quickly load you into a spacecraft and prepare to launch.

At  the first  Go  /  No Go  poll,  every Elf  is  Go  until the  Fuel
Counter-Upper.  They haven't  determined the  amount of  fuel required
yet.

Fuel   required  to   launch  a   given   module  is   based  on   its
mass. Specifically, to  find the fuel required for a  module, take its
mass, divide by three, round down, and subtract 2.

For example:
- For a mass of 12, divide by 3 and round down to get 4, then subtract
  2 to get 2.
- For a mass of 14, dividing by 3 and rounding down still yields 4, so
  the fuel required is also 2.
- For a mass of 1969, the fuel required is 654.
- For a mass of 100756, the fuel required is 33583.

The Fuel  Counter-Upper needs to  know the total fuel  requirement. To
find it, individually  calculate the fuel needed for the  mass of each
module (your puzzle input), then add together all the fuel values.

What is  the sum of  the fuel requirements for  all of the  modules on
your spacecraft?

#+begin_src fennel :session day01 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["12" "14" "1969" "100756"])

(fn fuel [mass]
  (- (aoc.int/ mass 3) 2))

(fn solve [input]
  (let [xs (lume.map input tonumber)]
    (accumulate [sum 0 _ x (ipairs xs)]
      (+ sum (fuel x)))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test (+ 2 2 654 33583) test-input)

(solve (aoc.string-from "2019/01.inp"))
#+end_src

#+RESULTS:
: 3560353

* DONE Day 1.2

During the  second Go / No  Go poll, the  Elf in charge of  the Rocket
Equation  Double-Checker stops  the launch  sequence. Apparently,  you
forgot to include additional fuel for the fuel you just added.

Fuel itself requires  fuel just like a module -  take its mass, divide
by three, round down, and subtract 2. However, that fuel also requires
fuel, and  that fuel  requires fuel,  and so on.  Any mass  that would
require negative fuel should instead be treated as if it requires zero
fuel; the remaining mass, if any, is instead handled by wishing really
hard, which has no mass and is outside the scope of this calculation.

So,  for each  module  mass, calculate  its  fuel and  add  it to  the
total. Then,  treat the fuel amount  you just calculated as  the input
mass and  repeat the process,  continuing until a fuel  requirement is
zero or negative. For example:
- A module of  mass 14 requires 2 fuel. This  fuel requires no further
  fuel (2 divided by  3 and rounded down is 0, which  would call for a
  negative fuel), so the total fuel required is still just 2.
- At first, a  module of mass 1969 requires 654  fuel. Then, this fuel
  requires 216  more fuel  (654 / 3  - 2). 216  then requires  70 more
  fuel, which requires 21 fuel,  which requires 5 fuel, which requires
  no further  fuel. So, the total  fuel required for a  module of mass
  1969 is 654 + 216 + 70 + 21 + 5 = 966.
- The  fuel required  by a  module  of mass  100756 and  its fuel  is:
  33583 + 11192 + 3728 + 1240 + 411 + 135 + 43 + 12 + 2 = 50346.
  
What is  the sum of  the fuel requirements for  all of the  modules on
your spacecraft  when also taking into  account the mass of  the added
fuel?  (Calculate the  fuel requirements  for each  module separately,
then add them all up at the end.)

#+begin_src fennel :session day01 :exports both
(fn added-fuel [mass]
  (let [res (aoc.lazy-seq [mass] fuel)]
    (aoc.table-sum (aoc.table-range res 2 (length res)))))

(fn solve2 [input]
  (let [xs (lume.map input tonumber)]
    (accumulate [sum 0 _ x (ipairs xs)]
      (+ sum (added-fuel x)))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 (+ 2 2 966 50346) test-input)

(solve2 (aoc.string-from "2019/01.inp"))
#+end_src

#+RESULTS:
: 5337642

* DONE Day 2.1

On the way to your gravity  assist around the Moon, your ship computer
beeps angrily  about a "1202 program  alarm". On the radio,  an Elf is
already explaining how  to handle the situation:  "Don't worry, that's
perfectly norma--" The ship computer bursts into flames.

You notify  the Elves that  the computer's  magic smoke seems  to have
escaped. "That computer  ran Intcode programs like  the gravity assist
program it  was working  on; surely  there are  enough spare  parts up
there to build a new Intcode computer!"

An Intcode  program is a  list of  integers separated by  commas (like
1,0,0,3,99). To run one, start by looking at the first integer (called
position 0). Here, you  will find an opcode - either 1,  2, or 99. The
opcode indicates what to do; for example, 99 means that the program is
finished and  should immediately halt. Encountering  an unknown opcode
means something went wrong.

Opcode 1 adds together numbers read  from two positions and stores the
result in a  third position. The three integers  immediately after the
opcode tell  you these three  positions -  the first two  indicate the
positions from which  you should read the input values,  and the third
indicates the position at which the output should be stored.

For example, if your Intcode computer encounters 1,10,20,30, it should
read the  values at positions  10 and 20,  add those values,  and then
overwrite the value at position 30 with their sum.

Opcode 2  works exactly like  opcode 1,  except it multiplies  the two
inputs instead  of adding  them. Again, the  three integers  after the
opcode indicate where the inputs and outputs are, not their values.

Once  you're done  processing  an  opcode, move  to  the  next one  by
stepping forward 4 positions.

For example, suppose you have the following program:

#+begin_example
1,9,10,3,2,3,11,0,99,30,40,50
#+end_example

For the purposes of illustration, here  is the same program split into
multiple lines:

#+begin_example
1,9,10,3,
2,3,11,0,
99,
30,40,50
#+end_example

The  first  four  integers,  1,9,10,3,  are  at  positions  0,  1,  2,
and 3.  Together, they represent  the first opcode (1,  addition), the
positions of the two inputs (9 and 10), and the position of the output
(3). To handle  this opcode, you first  need to get the  values at the
input   positions:   position  9   contains   30,   and  position   10
contains 40.  Add these numbers together  to get 70. Then,  store this
value at  the output  position; here,  the output  position (3)  is at
position 3, so it overwrites itself. Afterward, the program looks like
this:

#+begin_example
1,9,10,70,
2,3,11,0,
99,
30,40,50
#+end_example

Step forward  4 positions  to reach  the next  opcode, 2.  This opcode
works just like the previous, but it multiplies instead of adding. The
inputs are  at positions 3 and  11; these positions contain  70 and 50
respectively.  Multiplying  these produces  3500;  this  is stored  at
position 0:

#+begin_example
3500,9,10,70,
2,3,11,0,
99,
30,40,50
#+end_example

Stepping forward  4 more positions  arrives at opcode 99,  halting the
program.

Here are the initial and final states of a few more small programs:
- 1,0,0,0,99 becomes 2,0,0,0,99 (1 + 1 = 2).
- 2,3,0,3,99 becomes 2,3,0,6,99 (3 * 2 = 6).
- 2,4,4,5,99,0 becomes 2,4,4,5,99,9801 (99 * 99 = 9801).
- 1,1,1,4,99,5,6,0,99 becomes 30,1,1,4,2,5,6,0,99.

Once you  have a working  computer, the first  step is to  restore the
gravity assist program (your puzzle input) to the "1202 program alarm"
state it  had just before the  last computer caught fire.  To do this,
before running the  program, replace position 1 with the  value 12 and
replace position 2 with the value 2.  What value is left at position 0
after the program halts?

#+begin_src fennel :session day02 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test1-input "1,9,10,3,2,3,11,0,99,30,40,50")
(local test2-input "1,0,0,0,99")
(local test3-input "2,3,0,3,99")
(local test4-input "2,4,4,5,99,0")
(local test5-input "1,1,1,4,99,5,6,0,99")

(fn solve [xs]
  (var pos 1)
  (var done false)
  (while (not done)
    (if (= 99 (. xs pos))
        (set done true)
        (let [res (+ 1 (. xs (+ pos 3)))
              lar (. xs (+ 1 (. xs (+ pos 1)))) 
              rar (. xs (+ 1 (. xs (+ pos 2))))]
          (case (. xs pos)
            1  (aoc.table-swap xs res (+ lar rar))
            2  (aoc.table-swap xs res (* lar rar)))))
    (when (not done)
      (set pos (+ 4 pos))))
  (. xs 1))

(fn test [expected input]
  (let [xs (aoc.string-tonumarray input)]
    (assert (= expected (solve xs)))))

(test 3500 test1-input)
(test 2 test2-input)
(test 2 test3-input)
(test 2 test4-input)
(test 30 test5-input)

(fn restore-gravity-assist [input]
  (let [xs (aoc.string-tonumarray input)]
    (aoc.table-swap xs 2 12)
    (aoc.table-swap xs 3 2)
    (solve xs)))

(restore-gravity-assist (. (aoc.string-from "2019/02.inp") 1))
#+end_src

#+RESULTS:
: 7594646

* DONE Day 2.2

"Good, the new computer seems to  be working correctly! Keep it nearby
during  this mission  - you'll  probably  use it  again. Real  Intcode
computers support many more features than  your new one, but we'll let
you know what they are as you need them."

"However, your  current priority  should be  to complete  your gravity
assist around the Moon. For this  mission to succeed, we should settle
on some terminology for the parts you've already built."

Intcode programs  are given as  a list  of integers; these  values are
used as the  initial state for the computer's =memory=.  When you run an
Intcode  program, make  sure to  start by  initializing memory  to the
program's  values. A  position in  memory  is called  an =address=  (for
example, the first value in memory is at "address 0").

Opcodes (like 1,  2, or 99) mark the beginning  of an instruction. The
values  used immediately  after  an  opcode, if  any,  are called  the
instruction's =parameters=.  For example,  in the instruction 1,2,3,4, 1
is the  opcode; 2,  3, and  4 are the  parameters. The  instruction 99
contains only an opcode and has no parameters.

The  address of  the  current instruction  is  called the  instruction
pointer;  it  starts  at  0.    After  an  instruction  finishes,  the
instruction  pointer  increases  by  the  =number  of  values  in  the
instruction=; until you add more instructions to the computer, this is
always  4  (1  opcode  +  3  parameters)  for  the  add  and  multiply
instructions.  (The  halt instruction  would increase  the instruction
pointer by 1, but it halts the program instead.)

"With terminology out of the way,  we're ready to proceed. To complete
the  gravity  assist, you  need  to  determine  =what pair  of  inputs
produces the output= 19690720."

The inputs  should still be provided  to the program by  replacing the
values at  addresses 1 and 2,  just like before. In  this program, the
value placed in address 1 is called  the =noun=, and the value placed in
address 2  is called the  =verb=. Each of the  two input values  will be
between 0 and 99, inclusive.

Once the  program has halted,  its output  is available at  address 0,
also just like before.  Each time you  try a pair of inputs, make sure
you first  =reset the computer's  memory to  the values in  the program=
(your  puzzle input)  -  in other  words, don't  reuse  memory from  a
previous attempt.

Find the  input noun and  verb that cause  the program to  produce the
output 19690720. =What is 100 *  noun + verb=?  (For example, if noun=12
and verb=2, the answer would be 1202.)

#+begin_src fennel :session day02 :exports both
(fn complete-gravity-assist [input]
  (var done false)
  (for [i 0 99 &until done]
    (for [j 0 99 &until done]
      (let [xs (aoc.string-tonumarray input)]
        (aoc.table-swap xs 2 i)
        (aoc.table-swap xs 3 j)
        (when (= 19690720 (solve xs))
          (set done (+ (* 100 i) j))))))
  done)

(complete-gravity-assist (. (aoc.string-from "2019/02.inp") 1))
#+end_src

#+RESULTS:
: 3376
* DONE Day 3.1

The gravity assist was successful, and  you're well on your way to the
Venus  refuelling station.  During the  rush back  on Earth,  the fuel
management system wasn't  completely installed, so that's  next on the
priority list.

Opening the front  panel reveals a jumble of  wires. Specifically, two
wires  are  connected to  a  central  port  and  extend outward  on  a
grid. You  trace the  path each  wire takes as  it leaves  the central
port, one wire per line of text (your puzzle input).

The  wires  twist and  turn,  but  the  two wires  occasionally  cross
paths. To  fix the circuit,  you need  to find the  intersection point
closest to the central port. Because the  wires are on a grid, use the
Manhattan  distance   for  this   measurement.  While  the   wires  do
technically cross  right at  the central port  where they  both start,
this point  does not  count, nor  does a wire  count as  crossing with
itself.

For example,  if the first  wire's path is R8,U5,L5,D3,  then starting
from the central port (o), it goes  right 8, up 5, left 5, and finally
down 3:

#+begin_example
...........
...........
...........
....+----+.
....|....|.
....|....|.
....|....|.
.........|.
.o-------+.
...........
#+end_example

Then, if the second wire's path is U7,R6,D4,L4, it goes up 7, right 6,
down 4, and left 4:

#+begin_example
...........
.+-----+...
.|.....|...
.|..+--X-+.
.|..|..|.|.
.|.-X--+.|.
.|..|....|.
.|.......|.
.o-------+.
...........
#+end_example

These wires cross at two locations  (marked X), but the lower-left one
is closer to the central port: its distance is 3 + 3 = 6.

Here are a few more examples:
- R75,D30,R83,U83,L12,D49,R71,U7,L72
- U62,R66,U55,R34,D71,R55,D58,R83 = distance 159
- R98,U47,R26,D63,R33,U87,L62,D20,R33,U53,R51
- U98,R91,D20,R16,D67,R40,U7,R15,U6,R7 = distance 135

What is  the Manhattan distance from  the central port to  the closest
intersection?

#+begin_src fennel :session day03 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test1-input
       ["R8,U5,L5,D3"
        "U7,R6,D4,L4"])
(local test2-input
       ["R75,D30,R83,U83,L12,D49,R71,U7,L72"
        "U62,R66,U55,R34,D71,R55,D58,R83"])
(local test3-input
       ["R98,U47,R26,D63,R33,U87,L62,D20,R33,U53,R51"
        "U98,R91,D20,R16,D67,R40,U7,R15,U6,R7"])

(fn find-cross [l1 l2]
  (let [res []]
    (for [i 3 (length l1)]
      (for [j 3 (length l2)]
        (let [s1 [(. l1 (- i 1)) (. l1 i)]
              s2 [(. l2 (- j 1)) (. l2 j)]
              found (aoc.intersection s1 s2)]
          (when found
            (table.insert res found)))))
    res))

(fn solve [input]
  (let [line1 (aoc.decartian (. input 1))
        line2 (aoc.decartian (. input 2))
        res (find-cross line1 line2)]
    (aoc.math-min (lume.map res (fn [e] (aoc.manhattan-dist [0 0] e))))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 6 test1-input)
(test 159 test2-input)
(test 135 test3-input)
(solve (aoc.string-from "2019/03.inp"))
#+end_src

#+RESULTS:
: 209

* DONE Day 3.2

It turns out that this  circuit is very timing-sensitive; you actually
need to =minimize the signal delay=.

To do  this, calculate the  number of steps  each wire takes  to reach
each  intersection; choose  the  intersection where  the  sum of  both
wires'  steps is  lowest. If  a  wire visits  a position  on the  grid
multiple times, use the steps value from the first time it visits that
position when calculating the total value of a specific intersection.

The number of steps  a wire takes is the total  number of grid squares
the  wire  has  entered  to   get  to  that  location,  including  the
intersection being considered. Again consider the example from above:

#+begin_example
...........
.+-----+...
.|.....|...
.|..+--X-+.
.|..|..|.|.
.|.-X--+.|.
.|..|....|.
.|.......|.
.o-------+.
...........
#+end_example

In the above example, the intersection  closest to the central port is
reached after 8+5+5+2  = 20 steps by  the first wire and  7+6+4+3 = 20
steps by the second wire for a total of 20+20 = 40 steps.

However, the  top-right intersection is  better: the first  wire takes
only 8+5+2 = 15 and the second wire  takes only 7+6+2 = 15, a total of
15+15 = 30 steps.

Here are the best steps for the extra examples from above:
- R75,D30,R83,U83,L12,D49,R71,U7,L72
- U62,R66,U55,R34,D71,R55,D58,R83 = 610 steps
- R98,U47,R26,D63,R33,U87,L62,D20,R33,U53,R51
- U98,R91,D20,R16,D67,R40,U7,R15,U6,R7 = 410 steps

What is  the fewest  combined steps  the wires must  take to  reach an
intersection?


#+begin_src fennel :session day03 :exports both
(fn linear-dist [p s]
  (var done false)
  (let [res []]
    (for [i 2 (length s) &until done]
      (let [s0 (. s (- i 1))
            s1 (. s i)]
        (set done (aoc.in-segment? p [s0 s1]))
        (if done
            (table.insert res (aoc.manhattan-dist s0 p))
            (table.insert res (aoc.manhattan-dist s0 s1)))))
    (aoc.table-sum res)))

(fn solve2 [input]
  (let [line1 (aoc.decartian (. input 1))
        line2 (aoc.decartian (. input 2))
        res (find-cross line1 line2)]
    (aoc.math-min
     (lume.map res (fn [e] (+ (linear-dist e line1)
                              (linear-dist e line2)))))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 30 test1-input)
(test2 610 test2-input)
(test2 410 test3-input)
(solve2 (aoc.string-from "2019/03.inp"))
#+end_src

#+RESULTS:
: 43258

* DONE Day 4.1

You arrive at the Venus fuel  depot only to discover it's protected by
a password. The  Elves had written the password on  a sticky note, but
someone threw it out.

However, they do remember a few key facts about the password:
- It is a six-digit number.
- The value is within the range given in your puzzle input.
- Two adjacent digits are the same (like 22 in 122345).
- Going from left to right, the digits never decrease; they only ever
  increase or stay the same (like 111123 or 135679).
  
Other than the range rule, the following are true:
- 111111 meets these criteria (double 11, never decreases).
- 223450 does not meet these criteria (decreasing pair of digits 50).
- 123789 does not meet these criteria (no double).

How many  different passwords  within 134792-675810 range meet these
criteria?

#+begin_src fennel :session day04 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn identity [a b]
  (= a b))

(fn adjacent? [xs]
  (let [bins (aoc.partition-by xs identity)]
    (lume.any bins #(< 1 (length $)))))

(fn never-decrease? [xs]
  (var res true)
  (for [i 2 (length xs) &until (not res)]
    (when (< (. xs i)
             (. xs (- i 1)))
      (set res false)))
  res)

(fn solve [f t]
  (var res 0)
  (for [i f t]
    (let [xs (aoc.toarray i)]
      (when (and (adjacent? xs)
                 (never-decrease? xs))
        (set res (+ 1 res)))))
  res)

(solve 134792 675810)
#+end_src

#+RESULTS:
: 1955

* DONE Day 4.2

An Elf  just remembered  one more important  detail: the  two adjacent
matching digits are not part of a larger group of matching digits.

Given this  additional criterion, but  still ignoring the  range rule,
the following are now true:
- 112233 meets  these criteria because  the digits never  decrease and
  all repeated digits are exactly two digits long.
- 123444 no  longer meets the criteria  (the repeated 44 is  part of a
  larger group of 444).
- 111122  meets the  criteria (even  though  1 is  repeated more  than
  twice, it still contains a double 22).
  
How many  different passwords  within the range  given in  your puzzle
input meet all of the criteria?

#+begin_src fennel :session day04 :exports both
(fn two-adjacent? [xs]
  (let [bins (aoc.partition-by xs identity)]
    (lume.any bins #(= 2 (length $)))))

(fn solve2 [f t]
  (var res 0)
  (for [i f t]
    (let [xs (aoc.toarray i)]
      (when (and (two-adjacent? xs)
                 (never-decrease? xs))
        (set res (+ 1 res)))))
  res)

(solve2 134792 675810)
#+end_src

#+RESULTS:
: 1319


* DONE Day 5.1

You're starting to sweat as the ship makes its way toward Mercury. The
Elves suggest  that you get  the air conditioner working  by upgrading
your  ship computer  to  support the  Thermal Environment  Supervision
Terminal.

The Thermal Environment Supervision  Terminal (TEST) starts by running
a diagnostic program (your puzzle  input). The TEST diagnostic program
will run on your existing Intcode computer after a few modifications:

First, you'll need to add two new instructions:
- Opcode 3 takes a single integer as input and saves it to the
  position given by its only parameter. For example, the instruction
  3,50 would take an input value and store it at address 50.
- Opcode 4 outputs the value of its only parameter. For example, the
  instruction 4,50 would output the value at address 50.
  
Programs that use these instructions will come with documentation that
explains what should be connected to the input and output. The program
3,0,4,0,99 outputs whatever it gets as input, then halts.

Second, you'll need to add support for parameter modes:

Each parameter  of an  instruction is handled  based on  its parameter
mode. Right now, your ship computer already understands parameter mode
0, position  mode, which causes the  parameter to be interpreted  as a
position - if  the parameter is 50,  its value is the  value stored at
address 50 in memory. Until now,  all parameters have been in position
mode.

Now, your ship computer will also need to handle parameters in mode 1,
immediate mode.  In immediate  mode, a parameter  is interpreted  as a
value - if the parameter is 50, its value is simply 50.

Parameter  modes are  stored in  the same  value as  the instruction's
opcode. The  opcode is a two-digit  number based only on  the ones and
tens digit  of the  value, that  is, the opcode  is the  rightmost two
digits  of the  first value  in  an instruction.  Parameter modes  are
single digits, one per parameter,  read right-to-left from the opcode:
the  first parameter's  mode  is  in the  hundreds  digit, the  second
parameter's mode is in the thousands digit, the third parameter's mode
is in the ten-thousands digit, and so on. Any missing modes are 0.

For example, consider the program 1002,4,3,4,33.

The first  instruction, 1002,4,3,4,  is a  multiply instruction  - the
rightmost  two digits  of  the  first value,  02,  indicate opcode  2,
multiplication. Then, going  right to left, the parameter  modes are 0
(hundreds digit), 1 (thousands digit), and 0 (ten-thousands digit, not
present and therefore zero):

#+begin_example
ABCDE
 1002

DE - two-digit opcode,      02 == opcode 2
 C - mode of 1st parameter,  0 == position mode
 B - mode of 2nd parameter,  1 == immediate mode
 A - mode of 3rd parameter,  0 == position mode,
                                  omitted due to being a leading zero
#+end_example

This  instruction  multiplies  its  first two  parameters.  The  first
parameter, 4 in position mode, works like it did before - its value is
the  value stored  at  address  4 (33).  The  second  parameter, 3  in
immediate mode, simply has value 3. The result of this operation, 33 *
3 =  99, is written  according to the  third parameter, 4  in position
mode,  which  also  works like  it  did  before  -  99 is  written  to
address 4.

Parameters that  an instruction writes  to will never be  in immediate
mode.

Finally, some notes:
- It  is important  to remember  that the  instruction pointer  should
  increase  by the  number  of  values in  the  instruction after  the
  instruction finishes.  Because of the new  instructions, this amount
  is no longer always 4.
- Integers can be  negative: 1101,100,-1,4,0 is a  valid program (find
  100 + -1, store the result in position 4).
  
The TEST diagnostic program will start by requesting from the user the
ID of the system to test by  running an input instruction - provide it
1, the ID for the ship's air conditioner unit.

It  will then  perform a  series of  diagnostic tests  confirming that
various parts of the Intcode  computer, like parameter modes, function
correctly. For each test, it will run an output instruction indicating
how far the  result of the test  was from the expected  value, where 0
means the test  was successful. Non-zero outputs mean  that a function
is not working correctly; check  the instructions that were run before
the output instruction to see which one failed.

Finally, the  program will  output a  diagnostic code  and immediately
halt. This final output isn't an error; an output followed immediately
by a halt means the program  finished. If all outputs were zero except
the diagnostic code, the diagnostic program ran successfully.

After providing  1 to the only  input instruction and passing  all the
tests, what diagnostic code does the program produce?

#+begin_src fennel :session day05 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn intcode [xs input]
  (var pos 1)
  (var done false)
  (var output nil)
  (while (not done)
    (let [code (aoc.table-range xs pos (+ pos 3))]
      (case code
        [99]
        (set done true)
        [1 la ra re]
        (aoc.table-swap xs (+ 1 re) (+ (. xs (+ 1 la)) (. xs (+ 1 ra))))
        [1001 la ra re]
        (aoc.table-swap xs (+ 1 re) (+ (. xs (+ 1 la)) ra))
        [101 la ra re]
        (aoc.table-swap xs (+ 1 re) (+ la (. xs (+ 1 ra))))
        [1101 la ra re]
        (aoc.table-swap xs (+ 1 re) (+ la ra))
        [2 la ra re]
        (aoc.table-swap xs (+ 1 re) (* (. xs (+ 1 la)) (. xs (+ 1 ra))))
        [1002 la ra re]
        (aoc.table-swap xs (+ 1 re) (* (. xs (+ 1 la)) ra))
        [102 la ra re]
        (aoc.table-swap xs (+ 1 re) (* la (. xs (+ 1 ra))))
        [1102 la ra re]
        (aoc.table-swap xs (+ 1 re) (* la ra))
        [3 re _ _]
        (aoc.table-swap xs (+ 1 re) input)
        [4 re _ _]
        (set output (. xs (+ 1 re)))
        [104 re _ _]
        (set output re)
        _
        (do (set done true)
            (print (.. "W: no match at " pos ": " (. xs pos)))))
      (when (not done)
        (if (lume.any [3 4 104] #(= $ (. code 1)))
            (set pos (+ 2 pos))
            (set pos (+ 4 pos))))))
  output)

(fn solve [input]
  (let [xs (aoc.string-tonumarray (. input 1))]
    (intcode xs 1)))

(solve (aoc.string-from "2019/05.inp"))
#+end_src

#+RESULTS:
: 6069343


* DONE Day 5.2

The air conditioner comes online! Its cold air feels good for a while,
but then  the TEST alarms start  to go off. Since  the air conditioner
can't  vent its  heat  anywhere  but back  into  the spacecraft,  it's
actually making the air inside the ship =warmer=.

Instead,  you'll  need   to  use  the  TEST  to   extend  the  [[https://en.wikipedia.org/wiki/Spacecraft_thermal_control][thermal
radiators]]. Fortunately, the diagnostic  program (your puzzle input) is
already  equipped for  this. Unfortunately,  your Intcode  computer is
not.

Your computer is only missing a few opcodes:
- Opcode 5  is =jump-if-true=:  if the first  parameter is  =non-zero=, it
  sets  the  instruction   pointer  to  the  value   from  the  second
  parameter. Otherwise, it does nothing.
- Opcode 6 is  =jump-if-false=: if the first parameter =is  zero=, it sets
  the   instruction   pointer   to   the   value   from   the   second
  parameter. Otherwise, it does nothing.
- Opcode  7 is  =less than=:  if the  first parameter  =is less=  than the
  second parameter,  it stores 1  in the  position given by  the third
  parameter. Otherwise, it stores 0.
- Opcode 8  is =equals=: if the  first parameter is =equal  to= the second
  parameter,  it  stores  1  in   the  position  given  by  the  third
  parameter. Otherwise, it stores 0.
  
Like all  instructions, these instructions need  to support =parameter
modes= as described above.

Normally, after  an instruction  is finished, the  instruction pointer
increases by the number of values in that instruction. =However=, if the
instruction modifies the  instruction pointer, that value  is used and
the instruction pointer is =not automatically increased=.

For example, here are several programs that take one input, compare it
to the value 8, and then produce one output:
- 3,9,8,9,10,9,4,9,99,-1,8 - Using =position mode=, consider whether the
  input is =equal to= 8; output 1 (if it is) or 0 (if it is not).
- 3,9,7,9,10,9,4,9,99,-1,8 - Using =position mode=, consider whether the
  input is =less than= 8; output 1 (if it is) or 0 (if it is not).
- 3,3,1108,-1,8,3,4,3,99 - Using =immediate mode=, consider whether the
  input is =equal to= 8; output 1 (if it is) or 0 (if it is not).
- 3,3,1107,-1,8,3,4,3,99 - Using =immediate  mode=, consider whether the
  input is =less than= 8; output 1 (if it is) or 0 (if it is not).
  
Here are  some jump  tests that take  an input, then  output 0  if the
input was zero or 1 if the input was non-zero:
- 3,12,6,12,15,1,13,14,13,4,13,99,-1,0,1,9 (using =position mode=)
- 3,3,1105,-1,9,1101,0,0,12,4,12,99,1 (using =immediate mode=)

Here's a larger example:

#+begin_example
3,21,1008,21,8,20,1005,20,22,107,8,21,20,1006,20,31,1106,0,36,98,0,0,1002,21,125,20,4,20,1105,1,46,104,999,1105,1,46,1101,1000,1,20,4,20,1105,1,46,98,99
#+end_example

The  above example  program uses  an input  instruction to  ask for  a
single number. The program will then  output 999 if the input value is
below 8, output 1000 if the input  value is equal to 8, or output 1001
if the input value is greater than 8.

This time, when the TEST diagnostic program runs its input instruction
to get  the ID of  the system to  test, =provide it  5=, the ID  for the
ship's thermal  radiator controller.  This diagnostic test  suite only
outputs one number, the =diagnostic code=.

What is the diagnostic code for system ID 5?

#+begin_src fennel :session day05 :exports both
(fn intcode-v2 [xs input]
  (var pos 1)
  (var done false)
  (var output nil)
  (while (not done)
    (let [code (aoc.table-range xs pos (+ pos 3))]
      (case code
        [99]
        (set done true)
        [1 la ra re]
        (aoc.table-swap xs (+ 1 re) (+ (. xs (+ 1 la)) (. xs (+ 1 ra))))
        [101 la ra re]
        (aoc.table-swap xs (+ 1 re) (+ la (. xs (+ 1 ra))))
        [1001 la ra re]
        (aoc.table-swap xs (+ 1 re) (+ (. xs (+ 1 la)) ra))
        [1101 la ra re]
        (aoc.table-swap xs (+ 1 re) (+ la ra))
        [2 la ra re]
        (aoc.table-swap xs (+ 1 re) (* (. xs (+ 1 la)) (. xs (+ 1 ra))))
        [102 la ra re]
        (aoc.table-swap xs (+ 1 re) (* la (. xs (+ 1 ra))))
        [1002 la ra re]
        (aoc.table-swap xs (+ 1 re) (* (. xs (+ 1 la)) ra))
        [1102 la ra re]
        (aoc.table-swap xs (+ 1 re) (* la ra))
        [3 re _ _]
        (aoc.table-swap xs (+ 1 re) input)
        [4 re _ _]
        (set output (. xs (+ 1 re)))
        [104 re _ _]
        (set output re)
        [5 la ra _]
        (when (not= 0 (. xs (+ 1 la)))
          (set pos (+ 1 (. xs (+ 1 ra))))
          (set pos (+ 3 pos)))
        [105 la ra _]
        (if (not= 0 la)
          (set pos (+ 1 (. xs (+ 1 ra))))
          (set pos (+ 3 pos)))
        [1005 la ra _]
        (if (not= 0 (. xs (+ 1 la)))
          (set pos (+ 1 ra))
          (set pos (+ 3 pos)))
        [1105 la ra _]
        (if (not= 0 la)
          (set pos (+ 1 ra))
          (set pos (+ 3 pos)))
        [6 la ra _]
        (if (= 0 (. xs (+ 1 la)))
          (set pos (+ 1 (. xs (+ 1 ra))))
          (set pos (+ 3 pos)))
        [106 la ra _]
        (if (= 0 la)
          (set pos (+ 1 (. xs (+ 1 ra))))
          (set pos (+ 3 pos)))
        [1006 la ra _]
        (if (= 0 (. xs (+ 1 la)))
            (set pos (+ 1 ra))
            (set pos (+ 3 pos)))
        [1106 la ra _]
        (if (= 0 la)
            (set pos (+ 1 ra))
            (set pos (+ 3 pos)))
        [7 la ra re]
        (if (< (. xs (+ 1 la)) (. xs (+ 1 ra)))
            (aoc.table-swap xs (+ 1 re) 1)
            (aoc.table-swap xs (+ 1 re) 0))
        [107 la ra re]
        (if (< la (. xs (+ 1 ra)))
            (aoc.table-swap xs (+ 1 re) 1)
            (aoc.table-swap xs (+ 1 re) 0))
        [1007 la ra re]
        (if (< (. xs (+ 1 la)) ra)
            (aoc.table-swap xs (+ 1 re) 1)
            (aoc.table-swap xs (+ 1 re) 0))
        [1107 la ra re]
        (if (< la ra)
            (aoc.table-swap xs (+ 1 re) 1)
            (aoc.table-swap xs (+ 1 re) 0))
        [8 la ra re]
        (if (= (. xs (+ 1 la)) (. xs (+ 1 ra)))
            (aoc.table-swap xs (+ 1 re) 1)
            (aoc.table-swap xs (+ 1 re) 0))
        [108 la ra re]
        (if (= la (. xs (+ 1 ra)))
            (aoc.table-swap xs (+ 1 re) 1)
            (aoc.table-swap xs (+ 1 re) 0))
        [1008 la ra re]
        (if (= (. xs (+ 1 la)) ra)
            (aoc.table-swap xs (+ 1 re) 1)
            (aoc.table-swap xs (+ 1 re) 0))
        [1108 la ra re]
        (if (= la ra)
            (aoc.table-swap xs (+ 1 re) 1)
            (aoc.table-swap xs (+ 1 re) 0))
        _
        (do (set done true)
            (print (.. "W: no match at " pos ": " (. xs pos)))))
      (when (not done)
        (if (lume.any [3 4 104] #(= $ (. code 1)))
            (set pos (+ 2 pos))
            (lume.any [1005 1105 105 5 1006 1106 106 6]
                      #(= $ (. code 1)))
            nil
            (set pos (+ 4 pos))))))
  output)

(fn solve2 [lines input]
  (let [xs (aoc.string-tonumarray (. lines 1))]
    (intcode-v2 xs input)))

(fn test [expected lines input]
  (assert (= expected (solve2 lines input))))

(local test-input ["3,21,1008,21,8,20,1005,20,22,107,8,21,20,1006,20,31,1106,0,36,98,0,0,1002,21,125,20,4,20,1105,1,46,104,999,1105,1,46,1101,1000,1,20,4,20,1105,1,46,98,99"])
(test 999 test-input 7)
(test 1000 test-input 8)
(test 1001 test-input 9)

(local test2-input ["3,9,8,9,10,9,4,9,99,-1,8"])
(test 1 test2-input 8)
(test 0 test2-input 7)

(local test3-input ["3,9,7,9,10,9,4,9,99,-1,8"])
(test 0 test3-input 8)
(test 1 test3-input 7)

(local test4-input ["3,3,1108,-1,8,3,4,3,99"])
(test 1 test4-input 8)
(test 0 test4-input 7)

(local test5-input ["3,3,1107,-1,8,3,4,3,99"])
(test 0 test5-input 8)
(test 1 test5-input 7)

(local test6-input ["3,12,6,12,15,1,13,14,13,4,13,99,-1,0,1,9"])
(test 0 test6-input 0)
(test 1 test6-input 1)

(local test7-input ["3,3,1105,-1,9,1101,0,0,12,4,12,99,1"])
(test 0 test7-input 0)
(test 1 test7-input 1)

(solve2 (aoc.string-from "2019/05.inp") 5)
#+end_src

#+RESULTS:
: 3188550

* DONE Day 6.1

You've landed at the Universal  Orbit Map facility on Mercury. Because
navigation in  space often  involves transferring between  orbits, the
orbit maps here  are useful for finding efficient  routes between, for
example, you and  Santa. You download a map of  the local orbits (your
puzzle input).

Except for the  universal Center of Mass (COM), every  object in space
is in  orbit around exactly one  other object. An orbit  looks roughly
like this:

#+begin_example
                  \
                   \
                    |
                    |
AAA--> o            o <--BBB
                    |
                    |
                   /
                  /
#+end_example

In this diagram, the object BBB is  in orbit around AAA. The path that
BBB takes around  AAA (drawn with lines) is only  partly shown. In the
map data,  this orbital relationship  is written AAA)BBB,  which means
"BBB is in orbit around AAA".

Before you use your  map data to plot a course, you  need to make sure
it wasn't corrupted during the download. To verify maps, the Universal
Orbit Map  facility uses orbit count  checksums - the total  number of
direct orbits (like the one shown above) and indirect orbits.

Whenever A orbits B  and B orbits C, then A  indirectly orbits C. This
chain can be  any number of objects  long: if A orbits B,  B orbits C,
and C orbits D, then A indirectly orbits D.

For example, suppose you have the following map:
#+begin_example
COM)B
B)C
C)D
D)E
E)F
B)G
G)H
D)I
E)J
J)K
K)L
#+end_example

Visually, the above map of orbits looks like this:

#+begin_example
        G - H       J - K - L
       /           /
COM - B - C - D - E - F
               \
                I
#+end_example

In this  visual representation,  when two objects  are connected  by a
line, the one on the right directly orbits the one on the left.

Here, we can count the total number of orbits as follows:
- D directly orbits C and indirectly orbits B and COM, a total of 3
  orbits.
- L directly orbits K and indirectly orbits J, E, D, C, B, and COM, a
  total of 7 orbits.
- COM orbits nothing.

The total number of direct and indirect orbits in this example is 42.

What is the total number of direct and indirect orbits in your map
data?

#+begin_src fennel :session day06 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["COM)B"
                   "B)C"
                   "C)D"
                   "D)E"
                   "E)F"
                   "B)G"
                   "G)H"
                   "D)I"
                   "E)J"
                   "J)K"
                   "K)L"])

(fn paths [xs]
  (let [res {}]
    (each [_ [k v] (ipairs xs)]
      (tset res v k))
    res))

(fn solve [input]
  (let [xs (paths (lume.map input #(aoc.string-split $ ")")))
        ys (lume.map (aoc.keys xs) #(aoc.rank xs $))]
    (accumulate [sum 0 _ y (ipairs ys)]
      (+ sum y))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 42 test-input)

(solve (aoc.string-from "2019/06.inp"))
#+end_src

#+RESULTS:
: 151345

* DONE Day 6.2

Now, you just need to figure  out how many orbital transfers you (YOU)
need to take to get to Santa (SAN).

You start  at the  object YOU  are orbiting;  your destination  is the
object SAN  is orbiting. An  orbital transfer  lets you move  from any
object to an object orbiting or orbited by that object.

For example, suppose you have the following map:

#+begin_example
COM)B
B)C
C)D
D)E
E)F
B)G
G)H
D)I
E)J
J)K
K)L
K)YOU
I)SAN
#+end_example

Visually, the above map of orbits looks like this:

#+begin_example
                          YOU
                         /
        G - H       J - K - L
       /           /
COM - B - C - D - E - F
               \
                I - SAN
#+end_example

In this example, YOU are in orbit around K, and SAN is in orbit around
I. To move from K to I, a minimum of 4 orbital transfers are required:
- K to J
- J to E
- E to D
- D to I

Afterward, the map of orbits looks like this:

#+begin_example
        G - H       J - K - L
       /           /
COM - B - C - D - E - F
               \
                I - SAN
                 \
                  YOU
#+end_example

What is the minimum number of  orbital transfers required to move from
the object  YOU are orbiting to  the object SAN is  orbiting? (Between
the objects they are orbiting - not between YOU and SAN.)

#+begin_src fennel :session day06 :exports both
(local test2-input
       ["COM)B"
        "B)C"
        "C)D"
        "D)E"
        "E)F"
        "B)G"
        "G)H"
        "D)I"
        "E)J"
        "J)K"
        "K)L"
        "K)YOU"
        "I)SAN"])

(fn partial-paths [xs x y]
  (let [x1 (. xs x)
        y1 (. xs y)]
    (if (= x y) x
        (= x1 y1) x1
        (<= (aoc.rank xs x1) (aoc.rank xs y1))
        (partial-paths xs x1 (. xs y1))
        (partial-paths xs (. xs x1) y1))))

(fn solve2 [input]
  (let [xs (paths (lume.map input #(aoc.string-split $ ")")))
        x (partial-paths xs :YOU :SAN)]
    (- (+ (aoc.rank xs (. xs :SAN))
          (aoc.rank xs (. xs :YOU)))
       (* 2 (aoc.rank xs x)))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 4 test2-input)

(solve2 (aoc.string-from "2019/06.inp"))
#+end_src

#+RESULTS:
: 391


* DONE Day 8.1

The  Elves'  spirits  are  lifted   when  they  realize  you  have  an
opportunity  to reboot  one  of their  Mars rovers,  and  so they  are
curious if you would spend a brief sojourn on Mars. You land your ship
near the rover.

When  you reach  the  rover, you  discover that  it's  already in  the
process of  rebooting! It's just waiting  for someone to enter  a BIOS
password. The  Elf responsible for  the rover  takes a picture  of the
password  (your puzzle  input) and  sends it  to you  via the  Digital
Sending Network.

Unfortunately,  images sent  via  the Digital  Sending Network  aren't
encoded  with  any normal  encoding;  instead,  they're encoded  in  a
special Space  Image Format. None  of the  Elves seem to  remember why
this is the case. They send you the instructions to decode it.

Images are sent as a series of digits that each represent the color of
a single pixel.  The digits fill each row of  the image left-to-right,
then move downward  to the next row, filling  rows top-to-bottom until
every pixel of the image is filled.

Each image actually  consists of a series  of identically-sized layers
that are  filled in this way.  So, the first digit  corresponds to the
top-left pixel of the first layer, the second digit corresponds to the
pixel to the right of that on the same layer, and so on until the last
digit, which corresponds to the bottom-right pixel of the last layer.

For example, given an image 3 pixels wide and 2 pixels tall, the image
data 123456789012 corresponds to the following image layers:

#+begin_example
Layer 1: 123
         456

Layer 2: 789
         012
#+end_example

The image you received is 25 pixels wide and 6 pixels tall.

To make sure the image wasn't corrupted during transmission, the Elves
would like you to find the layer that contains the fewest 0 digits. On
that layer, what is the number of 1 digits multiplied by the number of
2 digits?

#+begin_src fennel :session day08 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve [input w h]
  (let [res {:k 100000000 :v 0}
        layers (aoc.table-group-by (aoc.string-toarray input) (* w h))]
    (each [_ layer (ipairs layers)]
      (let [zeros (length (lume.filter layer #(= "0" $)))
            ones (length (lume.filter layer #(= "1" $)))
            twos (length (lume.filter layer #(= "2" $)))]
        (when (< zeros (?. res :k))
            (tset res :k zeros)
            (tset res :v (* ones twos)))))
    (. res :v)))

(fn test [expected input w h]
  (let [image-data (. input 1)]
    (assert (= expected (solve image-data w h)))))

(local test-input ["123456789012"])

(test 1 test-input 3 2)

(solve (. (aoc.string-from "2019/08.inp") 1) 25 6)
#+end_src

#+RESULTS:
: 1584


* TODO Day 8.2

Now  you're ready  to  decode  the image.  The  image  is rendered  by
stacking the layers and aligning the pixels with the same positions in
each layer. The digits indicate  the color of the corresponding pixel:
0 is black, 1 is white, and 2 is transparent.

The layers  are rendered with  the first layer  in front and  the last
layer in back. So, if a given  position has a transparent pixel in the
first and second layers, a black pixel in the third layer, and a white
pixel in the fourth layer, the final image would have a =black= pixel at
that position.

For example, given an image 2 pixels wide and 2 pixels tall, the image
data =0222112222120000= corresponds to the following image layers:

#+begin_example
Layer 1:>02
         22

Layer 2: 11<
         22

Layer 3: 22
        >12

Layer 4: 00
         00<
#+end_example

Then, the full image can be found by determining the top visible pixel
in each position:
- The top-left pixel is =black= because the top layer is 0.
- The  top-right   pixel  is  =white=   because  the  top  layer   is  2
  (transparent), but the second layer is 1.
- The bottom-left pixel is =white= because the top two layers are 2, but
  the third layer is 1.
- The bottom-right  pixel is =black=  because the only visible  pixel in
  that position is 0 (from layer 4).
  
So, the final image looks like this:

#+begin_example
01
10
#+end_example

What message is produced after decoding your image?
