#+TITLE: 2018 challenge
#+AUTHOR: Advent of code
#+EMAIL: nazar@autistici.org
#+LANGUAGE: en
#+OPTIONS: toc:nil

* DONE Day 1.1
"We've detected some temporal anomalies,"  one of Santa's Elves at the
Temporal  Anomaly  Research  and Detection  Instrument  Station  tells
you. She  sounded pretty worried  when she  called you down  here. "At
500-year intervals  into the past,  someone has been  changing Santa's
history!"

"The good news is that the  changes won't propagate to our time stream
for another 25 days, and we have a device" - she attaches something to
your  wrist  -  "that will  let  you  fix  the  changes with  no  such
propagation delay. It's configured to  send you 500 years further into
the past every few  days; that was the best we could  do on such short
notice."

"The  bad  news is  that  we  are  detecting roughly  fifty  anomalies
throughout  time;  the  device  will  indicate  fixed  anomalies  with
stars. The other bad  news is that we only have  one device and you're
the best  person for  the job!  Good lu--"  She taps  a button  on the
device and you  suddenly feel like you're falling.  To save Christmas,
you need to get all fifty stars by December 25th.

Collect stars by  solving puzzles. Two puzzles will  be made available
on each day in the Advent calendar; the second puzzle is unlocked when
you complete the first. Each puzzle grants one star. Good luck!

After feeling like you've been falling  for a few minutes, you look at
the device's  tiny screen.  "Error: Device  must be  calibrated before
first  use.  Frequency  drift detected.  Cannot  maintain  destination
lock." Below  the message, the device  shows a sequence of  changes in
frequency  (your puzzle  input). A  value  like +6  means the  current
frequency increases by 6; a value  like -3 means the current frequency
decreases by 3.

For example, if  the device displays frequency changes of  +1, -2, +3,
+1,  then starting  from a  frequency of  zero, the  following changes
would occur:
- Current frequency  0, change of +1; resulting frequency  1.
- Current frequency  1, change of -2; resulting frequency -1.
- Current frequency -1, change of +3; resulting frequency  2.
- Current frequency  2, change of +1; resulting frequency  3.

In this example, the resulting frequency is 3.

Here are other example situations:
#+begin_example
    +1, +1, +1 results in  3
    +1, +1, -2 results in  0
    -1, -2, -3 results in -6
#+end_example

Starting with  a frequency  of zero, what  is the  resulting frequency
after all of the changes in frequency have been applied?

#+begin_src fennel :session day01 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["+1" "-2" "+3" "+1"])

(fn solve [input]
  (let [freq (lume.map input #(tonumber $))]
    (accumulate [sum 0 _ f (ipairs freq)]
      (+ sum f))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 3 test-input)

(solve (aoc.string-from "2018/01.inp"))
#+end_src

#+RESULTS:
: 574


* DONE Day 1.2

You notice that the device repeats the same frequency change list over
and  over.  To calibrate  the  device,  you  need  to find  the  first
frequency it reaches twice.

For example, using the same list of changes above, the device would
loop as follows:
- Current frequency  0, change of +1; resulting frequency  1.
- Current frequency  1, change of -2; resulting frequency -1.
- Current frequency -1, change of +3; resulting frequency  2.
- Current frequency  2, change of +1; resulting frequency  3.
- (At this point, the device continues from the start of the list.)
- Current frequency  3, change of +1; resulting frequency  4.
- Current frequency  4, change of -2; resulting frequency  2, which
  has already been seen.
  
In this  example, the first  frequency reached  twice is 2.  Note that
your device  might need to repeat  its list of frequency  changes many
times before a duplicate frequency is found, and that duplicates might
be found while in the middle of processing the list.

Here are other examples:
- +1, -1 first reaches 0 twice.
- +3, +3, +4, -2, -4 first reaches 10 twice.
- -6, +3, +8, +5, -6 first reaches 5 twice.
- +7, +7, -2, -7, -4 first reaches 14 twice.

What is the first frequency your device reaches twice?

#+begin_src fennel :session day01 :exports both
(fn solve2 [input]
  (let [xs (lume.map input #(tonumber $))]
    (var pos 2)
    (var res [(. xs 1)])
    (var xi (+ (. xs pos) (. res (length res))))
    (while (= nil (lume.find res xi))
      (table.insert res xi)
      (set pos (aoc.modulo+ 1 pos (length xs)))
      (set xi (+ (. xs pos) (. res (length res)))))
    xi))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 2 test-input)

(local test2-input ["+3" "+3" "+4" "-2" "-4"])
(test2 10 test2-input)

(local test3-input ["-6" "+3" "+8" "+5" "-6"])
(test2 5 test3-input)

(local test4-input ["+7" "+7" "-2" "-7" "-4"])
(test2 14 test4-input)

(solve2 (aoc.string-from "2018/01.inp"))
#+end_src

#+RESULTS:
: 452


* DONE Day 2.1

You stop falling through time, catch your breath, and check the screen
on  the  device. "Destination  reached.  Current  Year: 1518.  Current
Location: North Pole Utility Closet 83N10."  You made it! Now, to find
those anomalies.

Outside the  utility closet, you  hear footsteps and a  voice. "...I'm
not sure either.  But now that so many people  have chimneys, maybe he
could sneak  in that  way?" Another  voice responds,  "Actually, we've
been working  on a  new kind of  suit that would  let him  fit through
tight spaces like  that. But, I heard  that a few days  ago, they lost
the prototype fabric, the design plans, everything! Nobody on the team
can even seem to remember important details of the project!"

"Wouldn't they  have had enough  fabric to  fill several boxes  in the
warehouse?  They'd  be stored  together,  so  the  box IDs  should  be
similar. Too bad it would take forever to search the warehouse for two
similar box IDs..." They walk too far away to hear any more.

Late at night,  you sneak to the  warehouse - who knows  what kinds of
paradoxes you could cause if you  were discovered - and use your fancy
wrist  device to  quickly scan  every box  and produce  a list  of the
likely candidates (your puzzle input).

To make sure you didn't miss  any, you scan the likely candidate boxes
again, counting the  number that have an ID containing  exactly two of
any letter  and then separately  counting those with exactly  three of
any  letter. You  can  multiply those  two counts  together  to get  a
rudimentary checksum and compare it to what your device predicts.

For example, if you see the following box IDs:
- abcdef contains no letters that appear exactly two or three times.
- bababc contains two a and three b, so it counts for both.
- abbcde contains two b, but no letter appears exactly three times.
- abcccd contains three c, but no letter appears exactly two times.
- aabcdd contains two a and two d, but it only counts once.
- abcdee contains two e.
- ababab contains three a and three b, but it only counts once.

Of these box IDs, four of  them contain a letter which appears exactly
twice, and three of them contain  a letter which appears exactly three
times. Multiplying these together produces a checksum of 4 * 3 = 12.

What is the checksum for your list of box IDs?

#+begin_src fennel :session day02 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["abcdef"
        "bababc"
        "abbcde"
        "abcccd"
        "aabcdd"
        "abcdee"
        "ababab"])

(fn solve [input]
  (var doubles 0)
  (var triples 0)
  (each [_ line (ipairs input)]
    (let [xs (aoc.table-sort (aoc.string-toarray line))
          bins (aoc.partition-by xs #(= $1 $2))]
      (when (< 0 (length (lume.filter bins #(= 2 (length $)))))
        (set doubles (+ 1 doubles)))
      (when (< 0 (length (lume.filter bins #(= 3 (length $)))))
        (set triples (+ 1 triples)))))
  (* doubles triples))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 12 test-input)

(solve (aoc.string-from "2018/02.inp"))
#+end_src

#+RESULTS:
: 3952

* TODO Day 2.2

Confident that your list of box  IDs is complete, you're ready to find
the boxes full of prototype fabric.

The boxes will  have IDs which differ by exactly  one character at the
same position  in both strings.  For example, given the  following box
IDs:

#+begin_example
abcde
fghij
klmno
pqrst
fguij
axcye
wvxyz
#+end_example

The IDs abcde  and axcye are close, but they  differ by two characters
(the second  and fourth). However, the  IDs fghij and fguij  differ by
exactly one character, the third (h  and u). Those must be the correct
boxes.

What  letters are  common between  the two  correct box  IDs? (In  the
example above, this is found  by removing the differing character from
either ID, producing fgij.)
