#+TITLE: 2023 challenge
#+AUTHOR: Advent of code
#+EMAIL: nazar@autistici.org
#+LANGUAGE: en
#+OPTIONS: title:t author:t email:nil toc:nil num:nil timestamp:nil

* DONE Day 1.1
You  try to  ask  why they  can't  just use  a  weather machine  ("not
powerful enough") and  where they're even sending you  ("the sky") and
why your  map looks mostly blank  ("you sure ask a  lot of questions")
and hang on did  you just say the sky ("of course,  where do you think
snow comes from") when you realize  that the Elves are already loading
you into a trebuchet ("please hold still, we need to strap you in").

As  they're making  the final  adjustments, they  discover that  their
calibration document  (your puzzle input)  has been amended by  a very
young  Elf  who was  apparently  just  excited  to  show off  her  art
skills. Consequently, the Elves are  having trouble reading the values
on the document.

The  newly-improved calibration  document consists  of lines  of text;
each line originally  contained a specific calibration  value that the
Elves now need to recover. On  each line, the calibration value can be
found by combining the first digit  and the last digit (in that order)
to form a single two-digit number.

For example:
#+begin_example
1abc2
pqr3stu8vwx
a1b2c3d4e5f
treb7uchet
#+end_example

In this example, the calibration values of these four lines are 12,
38, 15, and 77. Adding these together produces 142.

Consider your entire calibration document. What is the sum of all of
the calibration values?

#+begin_src fennel :session day01
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn test-input-1 [lines]
  (let [numbers []]
    (each [_ line (ipairs lines)]
      (let [fd (string.match line "[0-9]")
            ld (string.match (string.reverse line) "[0-9]")]
        (table.insert numbers (tonumber (.. fd ld)))))
    (assert (= 142 (aoc.fold numbers)))))

(test-input-1 ["1abc2" "pqr3stu8vwx" "a1b2c3d4e5f" "treb7uchet"])

(fn sum-of-first-and-last-digit [lines]
  (let [numbers []]
    (each [_ line (ipairs lines)]
      (let [fd (string.match line "[0-9]")
            ld (string.match (string.reverse line) "[0-9]")]
        (table.insert numbers (tonumber (.. fd ld)))))
    (aoc.fold numbers)))

(sum-of-first-and-last-digit (aoc.string-from "2023/01.inp"))
#+end_src

#+RESULTS:
: 56506

* DONE Day 1.2
Your calculation isn't  quite right. It looks like some  of the digits
are actually  spelled out with  letters: one, two, three,  four, five,
six, seven, eight, and nine also count as valid "digits".

Equipped with  this new  information, you  now need  to find  the real
first and last digit on each line. For example:
#+begin_example
two1nine
eightwothree
abcone2threexyz
xtwone3four
4nineeightseven2
zoneight234
7pqrstsixteen
#+end_example

In this  example, the calibration values  are 29, 83, 13,  24, 42, 14,
and 76. Adding these together produces 281.

What is the sum of all of the calibration values?
#+begin_src fennel :session day01
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn starts-at-index [s idx pref]
  (= (string.sub s idx (- (+ idx (length pref)) 1)) pref))

(fn replace-by-index [line index]
  (let [new-line
        (if (starts-at-index line index "one")
            (string.gsub line "one" "o1e" 1)
            (starts-at-index line index "two")
            (string.gsub line "two" "t2o" 1)
            (starts-at-index line index "three")
            (string.gsub line "three" "th3ee" 1)
            (starts-at-index line index "four")
            (string.gsub line "four" "fo4r" 1)
            (starts-at-index line index "five")
            (string.gsub line "five" "fi5e" 1)
            (starts-at-index line index "six")
            (string.gsub line "six" "s6x" 1)
            (starts-at-index line index "seven")
            (string.gsub line "seven" "se7en" 1)
            (starts-at-index line index "eight")
            (string.gsub line "eight" "ei8ht" 1)
            (starts-at-index line index "nine")
            (string.gsub line "nine" "n9ne" 1)
            line)]
    (if (< (+ 1 index) (length new-line))
        (replace-by-index new-line (+ 1 index))
        new-line)))

(fn replace-literal-numbers [lines]
  (let [new-lines []]
    (each [_ line (ipairs lines)]
      (let [new-line (replace-by-index line 1)]
        (table.insert new-lines new-line)))
    new-lines))

(fn test-input-2 [lines]
  (let [numbers []]
    (each [_ line (ipairs lines)]
      (let [fd (string.match line "[0-9]")
            ld (string.match (string.reverse line) "[0-9]")]
        (table.insert numbers (tonumber (.. fd ld)))))
    (let [result  (aoc.fold numbers)]
      (assert (= 281 result)))))

(test-input-2
 (replace-literal-numbers
  ["two1nine"
   "eightwothree"
   "abcone2threexyz"
   "xtwone3four"
   "4nineeightseven2"
   "zoneight234"
   "7pqrstsixteen"]))

(sum-of-first-and-last-digit
 (replace-literal-numbers
  (aoc.string-from "2023/01.inp"))) 
#+end_src

#+RESULTS:
: 56017

* DONE Day 2.1
You're launched high into the  atmosphere! The apex of your trajectory
just barely  reaches the  surface of  a large  island floating  in the
sky. You gently land in a fluffy  pile of leaves. It's quite cold, but
you don't see much snow. An Elf runs over to greet you.

The Elf explains that you've arrived at Snow Island and apologizes for
the lack of snow. He'll be happy  to explain the situation, but it's a
bit of a walk, so you have  some time. They don't get many visitors up
here; would you like to play a game in the meantime?

As you walk,  the Elf shows you  a small bag and some  cubes which are
either red, green, or blue. Each time you play this game, he will hide
a secret number of cubes of each color in the bag, and your goal is to
figure out information about the number of cubes.

To get  information, once a  bag has been  loaded with cubes,  the Elf
will reach into the bag, grab a  handful of random cubes, show them to
you, and then put them back in the  bag. He'll do this a few times per
game.

You play several games and record the information from each game (your
puzzle input). Each game is listed with  its ID number (like the 11 in
Game 11:  ...) followed  by a semicolon-separated  list of  subsets of
cubes that were revealed from the bag (like 3 red, 5 green, 4 blue).

For example, the record of a few games might look like this:
#+begin_example
Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green
Game 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue
Game 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red
Game 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red
Game 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green
#+end_example

In game 1, three sets of cubes are revealed from the bag (and then put
back again). The first set is 3 blue cubes and 4 red cubes; the second
set is 1 red  cube, 2 green cubes, and 6 blue cubes;  the third set is
only 2 green cubes.

The Elf would first like to  know which games would have been possible
if the bag  contained only 12 red  cubes, 13 green cubes,  and 14 blue
cubes?

In the example  above, games 1, 2,  and 5 would have  been possible if
the bag had been loaded with that configuration. However, game 3 would
have been  impossible because at one  point the Elf showed  you 20 red
cubes  at once;  similarly, game  4  would also  have been  impossible
because the Elf  showed you 15 blue  cubes at once. If you  add up the
IDs of the games that would have been possible, you get 8.

Determine which  games would have  been possible  if the bag  had been
loaded with only 12 red cubes, 13 green cubes, and 14 blue cubes. What
is the sum of the IDs of those games?

#+begin_src fennel :session day02
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn parse-take [take]
  {:r (tonumber (string.match take "([0-9]*) red"))
   :g (tonumber (string.match take "([0-9]*) green"))
   :b (tonumber (string.match take "([0-9]*) blue"))})

(fn read-game [game]
  {:id (tonumber (string.match game "Game ([0-9]*):"))
   :takes (lume.map (aoc.string-split game ";") parse-take)})

(fn possible-take? [take]
  (let [max-red 12
        red (or (. take :r) 0)
        max-green 13
        green (or (. take :g) 0)
        max-blue 14
        blue (or (. take :b) 0)]
    (not (or (> red max-red)
             (> green max-green)
             (> blue max-blue)))))

(fn possible-game? [game]
  (= nil (lume.find (lume.map (. game :takes) possible-take?) false)))
  
(fn sum-game-ids [games]
  (accumulate [sum 0 _ game (ipairs games)]
    (+ sum (. game :id))))

(fn find-possible-games-ids [lines]
  (let [games []]
    (each [_ line (ipairs lines)]
      (let [game (read-game line)]
        (table.insert games game)))
    (sum-game-ids (lume.filter games possible-game?))))

(fn test-input [lines]
  (assert (= 8 (find-possible-games-ids lines))))

(local test-lines
       ["Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green"
        "Game 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue"
        "Game 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red"
        "Game 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red"
        "Game 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green"])

(test-input test-lines)

(find-possible-games-ids (aoc.string-from "2023/02.inp"))
#+end_src

#+RESULTS:
: 2449

* DONE Day 2.2
The  Elf  says they've  stopped  producing  snow because  they  aren't
getting any  water! He isn't sure  why the water stopped;  however, he
can  show you  how to  get to  the water  source to  check it  out for
yourself. It's just up ahead!

As you  continue your walk, the  Elf poses a second  question: in each
game you played, what is the fewest number of cubes of each color that
could have been in the bag to make the game possible?

Again consider the example games from earlier:
#+begin_example
Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green
Game 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue
Game 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red
Game 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red
Game 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green
#+end_example

- In game 1, the game could have been played with as few as 4 red, 2
  green, and 6 blue cubes. If any color had even one fewer cube, the
  game would have been impossible.
- Game 2 could have been played with a minimum of 1 red, 3 green, and
  4 blue cubes.
- Game 3 must have been played with at least 20 red, 13 green, and 6
  blue cubes.
- Game 4 required at least 14 red, 3 green, and 15 blue cubes.
- Game 5 needed no fewer than 6 red, 3 green, and 2 blue cubes in the
  bag.
  
The power of a set of cubes is equal to the numbers of red, green, and
blue cubes multiplied together. The power  of the minimum set of cubes
in  game  1 is  48.  In  games  2-5 it  was  12,  1560, 630,  and  36,
respectively. Adding up these five powers produces the sum 2286.

For each game, find the minimum set of cubes that must have been
present. What is the sum of the power of these sets?

#+begin_src fennel :session day02
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn find-max-red-take [game]
  (aoc.table-max
   (lume.map (. game :takes)
             (fn [take] (or (. take :r) 0)))))

(fn find-max-green-take [game]
  (aoc.table-max
   (lume.map (. game :takes)
             (fn [take] (or (. take :g) 0)))))

(fn find-max-blue-take [game]
  (aoc.table-max
   (lume.map (. game :takes)
             (fn [take] (or (. take :b) 0)))))

(fn find-game-power-cube [game]
  (*
   (find-max-red-take game)
   (find-max-green-take game)
   (find-max-blue-take game)))

(fn sum-game-power-cubes [lines]
  (let [power-cubes []]
    (each [_ line (ipairs lines)]
      (let [game (read-game line)]
        (table.insert power-cubes (find-game-power-cube game))))
    (aoc.table-sum power-cubes)))

(fn test-input2 [lines]
  (assert (= 2286 (sum-game-power-cubes lines))))

(test-input2 test-lines)
(sum-game-power-cubes (aoc.string-from "2023/02.inp"))

#+end_src

#+RESULTS:
: 63981

* DONE Day 4.1
The gondola takes  you up. Strangely, though, the  ground doesn't seem
to be coming  with you; you're not climbing a  mountain. As the circle
of  Snow Island  recedes below  you, an  entire new  landmass suddenly
appears above you!  The gondola carries you to the  surface of the new
island and lurches into the station.

As you exit  the gondola, the first  thing you notice is  that the air
here  is much  warmer than  it  was on  Snow Island.  It's also  quite
humid. Is this where the water source is?

The next thing  you notice is an  Elf sitting on the  floor across the
station in what seems to be a pile of colorful square cards.

"Oh! Hello!"  The Elf  excitedly runs over  to you. "How  may I  be of
service?" You ask about water sources.

"I'm not sure;  I just operate the gondola lift.  That does sound like
something we'd have, though - this  is Island Island, after all! I bet
the gardener would know. He's on  a different island, though - er, the
small kind surrounded by water, not  the floating kind. We really need
to come up with a better naming scheme. Tell you what: if you can help
me with something  quick, I'll let you  borrow my boat and  you can go
visit the  gardener. I  got all  these scratchcards as  a gift,  but I
can't figure out what I've won."

The  Elf leads  you over  to the  pile of  colorful cards.  There, you
discover  dozens  of  scratchcards,  all with  their  opaque  covering
already scratched off. Picking one up, it looks like each card has two
lists of  numbers separated by a  vertical bar (|): a  list of winning
numbers  and  then a  list  of  numbers  you  have. You  organize  the
information into a table (your puzzle input).

As far as the Elf has been able  to figure out, you have to figure out
which  of  the  numbers  you  have  appear  in  the  list  of  winning
numbers. The first match makes the card worth one point and each match
after the first doubles the point value of that card.

For example:
#+begin_example
Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53
Card 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19
Card 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1
Card 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83
Card 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36
Card 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11
#+end_example

In the above example, card 1 has five winning numbers (41, 48, 83, 86,
and 17)  and eight numbers  you have  (83, 86, 6,  31, 17, 9,  48, and
53). Of the  numbers you have, four  of them (48, 83, 17,  and 86) are
winning numbers! That means card 1 is  worth 8 points (1 for the first
match, then  doubled three times for  each of the three  matches after
the first).
- Card 2 has two winning numbers (32 and 61), so it is worth 2 points.
- Card 3 has two winning numbers (1 and 21), so it is worth 2 points.
- Card 4 has one winning number (84), so it is worth 1 point.
- Card 5 has no winning numbers, so it is worth no points.
- Card 6 has no winning numbers, so it is worth no points.

So,  in this  example,  the Elf's  pile of  scratchcards  is worth  13
points. Take  a seat  in the  large pile of  colorful cards.  How many
points are they worth in total?

#+begin_src fennel :session day04
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn table.intersect [lottery ticket]
  (let [t1 (table.sort lottery)
        t2 (table.sort ticket)
        result []]
    (each [_ val (ipairs lottery)]
      (when (lume.find ticket val)
        (table.insert result val)))
    result))

(fn read-game [s]
  (let [id (tonumber (string.match s "Card *([0-9]*):"))
        lottery (aoc.string-split (string.match s ":([0-9 ]*)|") " ")
        ticket (aoc.string-split (string.match s "|([0-9 ]*)$") " ")]
    {:id id :lottery (lume.map lottery tonumber) :ticket (lume.map ticket tonumber)}))

(fn read-games [lines]
  (let [result []]
    (each [_ line (ipairs lines)]
      (let [game (read-game line)]
        (table.insert result game)))
    result))

(fn wins-to-points [n]
  (if (> n 0)
      (aoc.math-pow 2 (- n 1))
      0))

(fn count-points [games]
  (let [result []]
    (each [_ game (ipairs games)]
      (let [wins (table.intersect (. game :lottery) (. game :ticket))
            points (wins-to-points (length wins))]
        (table.insert result points)))
    result))

(fn test-input [lines]
  (let [games (read-games lines)]
    (assert (= 13 (aoc.table-sum (count-points games))))))

(local test-lines
       ["Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53"
        "Card 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19"
        "Card 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1"
        "Card 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83"
        "Card 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36"
        "Card 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11"])

(test-input test-lines)

(fn real-input [lines]
  (let [games (read-games lines)]
    (aoc.table-sum (count-points games))))

(real-input (aoc.string-from "2023/04.inp"))
#+end_src

#+RESULTS:
: 18653

* DONE Day 4.2
Just as you're  about to report your  findings to the Elf,  one of you
realizes that  the rules  have actually  been printed  on the  back of
every card this whole time.

There's no  such thing as  "points". Instead, scratchcards  only cause
you to  win more scratchcards equal  to the number of  winning numbers
you have.

Specifically, you  win copies  of the  scratchcards below  the winning
card equal  to the number of  matches. So, if  card 10 were to  have 5
matching numbers, you would win one copy each of cards 11, 12, 13, 14,
and 15.

Copies of  scratchcards are scored  like normal scratchcards  and have
the same card number as the card they copied. So, if you win a copy of
card 10 and it has 5 matching numbers, it would then win a copy of the
same  cards that  the original  card  10 won:  cards 11,  12, 13,  14,
and 15. This process repeats until none of the copies cause you to win
any more cards. (Cards will never make you copy a card past the end of
the table.)

This time, the above example goes differently:
#+begin_example
Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53
Card 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19
Card 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1
Card 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83
Card 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36
Card 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11
#+end_example

- Card 1 has four matching numbers, so you win one copy each of the
  next four cards: cards 2, 3, 4, and 5.
- Your original card 2 has two matching numbers, so you win one copy
  each of cards 3 and 4.
- Your copy of card 2 also wins one copy each of cards 3 and 4.
- Your four instances of card 3 (one original and three copies) have
  two matching numbers, so you win four copies each of cards 4 and 5.
- Your eight instances of card 4 (one original and seven copies) have
  one matching number, so you win eight copies of card 5.
- Your fourteen instances of card 5 (one original and thirteen copies)
  have no matching numbers and win no more cards.
- Your one instance of card 6 (one original) has no matching numbers
  and wins no more cards.

Once all of  the originals and copies have been  processed, you end up
with 1 instance of card 1, 2  instances of card 2, 4 instances of card
3, 8 instances  of card 4, 14  instances of card 5, and  1 instance of
card 6.  In total,  this example  pile of  scratchcards causes  you to
ultimately have 30 scratchcards!

Process  all of  the original  and copied  scratchcards until  no more
scratchcards are won. Including the  original set of scratchcards, how
many total scratchcards do you end up with?

#+begin_src fennel :session day04
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn table.increment [t i v]
  (let [o (. t i)]
    (table.remove t i)
    (table.insert t i (+ o v)))
  t)

(fn collect-cards [games]
  (let [result []]
    (each [_ game (ipairs games)]
      (let [count (length (table.intersect (. game :lottery) (. game :ticket)))
            id (. game :id)
            cards []]
        (when (< 0 count)
          (fcollect [i (+ id 1) (+ count id) 1]
            (table.insert cards i)))
        (tset result id cards)))
    result))

(fn count-cards [games]
  (let [cards (collect-cards games)
        result (fcollect [i 1 (length cards) 1] 1)]
    (each [i v (ipairs cards)]
      (each [j w (ipairs v)]
        (table.increment result w (. result i))))
    result))

(fn test-input2 [lines]
  (let [games (read-games lines)]
    (assert (= 30 (aoc.table-sum (count-cards games))))))

(test-input2 test-lines)

(fn real-input2 [lines]
  (let [games (read-games lines)]
    (aoc.table-sum (count-cards games))))

(real-input2 (aoc.string-from "2023/04.inp"))
#+end_src

#+RESULTS:
: 5921508

* DONE Day 5.1
You take the boat  and find the gardener right where  you were told he
would be:  managing a  giant "garden"  that looks more  to you  like a
farm.

"A water  source? Island Island  is the  water source!" You  point out
that Snow Island isn't receiving any water.

"Oh, we had to stop the water because  we ran out of sand to filter it
with! Can't  make snow with dirty  water. Don't worry, I'm  sure we'll
get  more   sand  soon;   we  only   turned  off   the  water   a  few
days...  weeks... oh  no." His  face sinks  into a  look of  horrified
realization.

"I've  been  so  busy  making  sure everyone  here  has  food  that  I
completely forgot to check why we stopped getting more sand! There's a
ferry leaving soon  that is headed over in that  direction - it's much
faster than your boat. Could you please go check it out?"

You  barely have  time to  agree  to this  request when  he brings  up
another. "While you wait for the ferry, maybe you can help us with our
food production problem. The latest Island Island Almanac just arrived
and we're having trouble making sense of it."

The almanac (your puzzle input) lists all of the seeds that need to be
planted. It  also lists  what type of  soil to use  with each  kind of
seed, what type of fertilizer to use with each kind of soil, what type
of water to use with each kind of fertilizer, and so on. Every type of
seed, soil,  fertilizer and  so on  is identified  with a  number, but
numbers are reused by each category - that is, soil 123 and fertilizer
123 aren't necessarily related to each other.

For example:
#+begin_example
seeds: 79 14 55 13

seed-to-soil map:
50 98 2
52 50 48

soil-to-fertilizer map:
0 15 37
37 52 2
39 0 15

fertilizer-to-water map:
49 53 8
0 11 42
42 0 7
57 7 4

water-to-light map:
88 18 7
18 25 70

light-to-temperature map:
45 77 23
81 45 19
68 64 13

temperature-to-humidity map:
0 69 1
1 0 69

humidity-to-location map:
60 56 37
56 93 4
#+end_example

The almanac starts by listing which seeds need to be planted: seeds
79, 14, 55, and 13.

The rest of the almanac contains a  list of maps which describe how to
convert numbers from  a source category into numbers  in a destination
category.  That is,  the section  that starts  with seed-to-soil  map:
describes how to  convert a seed number (the source)  to a soil number
(the destination). This lets the gardener and his team know which soil
to use with which seeds, which water to use with which fertilizer, and
so on.

Rather than list every source number and its corresponding destination
number one by one, the maps describe entire ranges of numbers that can
be  converted. Each  line within  a  map contains  three numbers:  the
destination range start, the source range start, and the range length.

Consider again the example seed-to-soil map:
#+begin_example
50 98 2
52 50 48
#+end_example

The first  line has a  destination range start  of 50, a  source range
start of 98, and a range length  of 2. This line means that the source
range starts at 98 and contains two values: 98 and 99. The destination
range is the same  length, but it starts at 50, so  its two values are
50  and 51.  With  this  information, you  know  that  seed number  98
corresponds to soil  number 50 and that seed number  99 corresponds to
soil number 51.

The second line means that the  source range starts at 50 and contains
48 values:  50, 51,  ..., 96,  97. This  corresponds to  a destination
range  starting at  52 and  also containing  48 values:  52, 53,  ...,
98, 99. So, seed number 53 corresponds to soil number 55.

Any  source  numbers  that  aren't   mapped  correspond  to  the  same
destination number. So, seed number 10 corresponds to soil number 10.

So,  the entire  list of  seed  numbers and  their corresponding  soil
numbers looks like this:
#+begin_example
seed  soil
0     0
1     1
...   ...
48    48
49    49
50    52
51    53
...   ...
96    98
97    99
98    50
99    51
#+end_example

With  this map,  you can  look up  the soil  number required  for each
initial seed number:

- Seed number 79 corresponds to soil number 81.
- Seed number 14 corresponds to soil number 14.
- Seed number 55 corresponds to soil number 57.
- Seed number 13 corresponds to soil number 13.

The gardener and his team want to  get started as soon as possible, so
they'd like  to know  the closest  location that  needs a  seed. Using
these maps, find the lowest location number that corresponds to any of
the initial seeds. To do this, you'll need to convert each seed number
through other categories until you can find its corresponding location
number. In this example, the corresponding types are:

- Seed 79, soil 81, fertilizer 81, water 81, light 74, temperature 78, humidity 78, location 82.
- Seed 14, soil 14, fertilizer 53, water 49, light 42, temperature 42, humidity 43, location 43.
- Seed 55, soil 57, fertilizer 57, water 53, light 46, temperature 82, humidity 82, location 86.
- Seed 13, soil 13, fertilizer 52, water 41, light 34, temperature 34, humidity 35, location 35.

So, the lowest location number in this example is 35.

What is  the lowest  location number  that corresponds  to any  of the
initial seed numbers?

#+begin_src fennel :session day05
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn vec2tree2 [node t ?f]
  (let [len (length t)]
    (if (= 0 len) nil
        (= 1 len) (tset node :val (. t 1))
        (do
          (table.sort t ?f)
          (let [mid (math.ceil (/ len 2))
                left (aoc.table-range t 1 (- mid 1))
                right (aoc.table-range t (+ mid 1) len)]
            (tset node :val (. t mid))
            (when (not (aoc.empty? left)) (tset node :left (vec2tree2 {} left ?f)))
            (when (not (aoc.empty? right)) (tset node :right (vec2tree2 {} right ?f))))))
    node))

(fn comp [a b]
  (< (. a 2) (. b 2)))

(local seed2soil
       (vec2tree2 {}
                  [[50 98 2]
                   [52 50 48]]
                  comp))

(local soil2fertilizer
       (vec2tree2 {}
                  [[0 15 37]
                   [37 52 2]
                   [39 0 15]]
                  comp))

(local fertilizer2water
       (vec2tree2 {}
                  [[49 53 8]
                   [0 11 42]
                   [42 0 7]
                   [57 7 4]]
                  comp))


(local water2light
       (vec2tree2 {}
                  [[88 18 7]
                   [18 25 70]]
                  comp))

(local light2temperature
       (vec2tree2 {}
                  [[45 77 23]
                   [81 45 19]
                   [68 64 13]]
                  comp))

(local temperature2humidity
       (vec2tree2 {}
                  [[0 69 1]
                   [1 0 69]]
                  comp))

(local humidity2location
       (vec2tree2 {}
                  [[60 56 37]
                   [56 93 4]]
                  comp))

(local test-seeds
       [79 14 55 13])

(fn search-in-range [node v]
  (if node
      (let [from (. (. node :val) 2)
            to (- (+ from (. (. node :val) 3)) 1)]
        (if (< v from) (search-in-range (. node :left) v)
            (> v to) (search-in-range (. node :right) v)
            (and (<= from v) (<= v to)) (+ (- v from) (. (. node :val) 1))))
      v))

(fn seed2soil2fert2water2light2temp2hum2loc [x t1 t2 t3 t4 t5 t6 t7]
  (->> x
       (search-in-range t1)
       (search-in-range t2)
       (search-in-range t3)
       (search-in-range t4)
       (search-in-range t5)
       (search-in-range t6)
       (search-in-range t7)))

(fn test-input [xs t1 t2 t3 t4 t5 t6 t7]
  (let [locations []]
    (each [_ seed (ipairs xs)]
      (let [location (seed2soil2fert2water2light2temp2hum2loc seed t1 t2 t3 t4 t5 t6 t7)]
        (table.insert locations location)))
    (assert (= 35 (aoc.table-min locations)))))

(test-input test-seeds seed2soil soil2fertilizer fertilizer2water water2light light2temperature temperature2humidity humidity2location)

(fn real-input [xs]
  (let [locations []
        seeds (aoc.table-unpack (lume.map (aoc.table-range xs 1 1) #(aoc.string-tonumarray $)))
        t1 (vec2tree2 {} (lume.map (aoc.table-range xs 4 27) #(aoc.string-tonumarray $))  comp)
        t2 (vec2tree2 {} (lume.map (aoc.table-range xs 30 60) #(aoc.string-tonumarray $)) comp)
        t3 (vec2tree2 {} (lume.map (aoc.table-range xs 63 72) #(aoc.string-tonumarray $)) comp)
        t4 (vec2tree2 {} (lume.map (aoc.table-range xs 75 101) #(aoc.string-tonumarray $)) comp)
        t5 (vec2tree2 {} (lume.map (aoc.table-range xs 104 114) #(aoc.string-tonumarray $)) comp)
        t6 (vec2tree2 {} (lume.map (aoc.table-range xs 117 129) #(aoc.string-tonumarray $)) comp)
        t7 (vec2tree2 {} (lume.map (aoc.table-range xs 132 139) #(aoc.string-tonumarray $)) comp)]
    (each [_ seed (ipairs seeds)]
      (table.insert locations (seed2soil2fert2water2light2temp2hum2loc seed t1 t2 t3 t4 t5 t6 t7)))
    (aoc.table-min locations)))

(real-input (aoc.string-from "2023/05.inp"))
#+end_src

#+RESULTS:
: 1181555926

* DONE Day 6.1
The  ferry  quickly brings  you  across  Island Island.  After  asking
around, you  discover that there  is indeed  normally a large  pile of
sand somewhere near  here, but you don't see anything  besides lots of
water and the small island where the ferry has docked.

As you  try to figure out  what to do next,  you notice a poster  on a
wall near the ferry dock. "Boat races! Open to the public! Grand prize
is an all-expenses-paid trip to Desert Island!" That must be where the
sand comes from!  Best of all, the  boat races are starting  in just a
few minutes.

You  manage to  sign up  as a  competitor in  the boat  races just  in
time. The organizer explains that it's not really a traditional race -
instead, you  will get a fixed  amount of time during  which your boat
has to  travel as far  as it can,  and you win  if your boat  goes the
farthest.

As part of  signing up, you get  a sheet of paper  (your puzzle input)
that lists the  time allowed for each race and  also the best distance
ever recorded in that race. To  guarantee you win the grand prize, you
need to make sure you go farther  in each race than the current record
holder.

The organizer  brings you over  to the area  where the boat  races are
held. The boats are much smaller  than you expected - they're actually
toy boats,  each with  a big  button on top.  Holding down  the button
charges  the  boat,  and  releasing  the button  allows  the  boat  to
move. Boats  move faster  if their  button was  held longer,  but time
spent holding the  button counts against the total race  time. You can
only hold the  button at the start  of the race, and  boats don't move
until the button is released.

For example:
#+begin_example
Time:      7  15   30
Distance:  9  40  200
#+end_example

This document describes three races:
- The first race lasts 7 milliseconds. The record distance in this
  race is 9 millimeters.
- The second race lasts 15 milliseconds. The record distance in this
  race is 40 millimeters.
- The third race lasts 30 milliseconds. The record distance in this
  race is 200 millimeters.
  
Your  toy  boat   has  a  starting  speed  of   zero  millimeters  per
millisecond. For each whole millisecond  you spend at the beginning of
the race  holding down the button,  the boat's speed increases  by one
millimeter per millisecond.

So, because the first race lasts 7 milliseconds, you only have a few
options:
- Don't hold the  button at all (that is, hold  it for 0 milliseconds)
  at the start of the race. The boat won't move; it will have traveled
  0 millimeters by the end of the race.
- Hold the  button for 1 millisecond  at the start of  the race. Then,
  the boat will travel at a  speed of 1 millimeter per millisecond for
  6 milliseconds, reaching a total distance traveled of 6 millimeters.
- Hold the  button for 2  milliseconds, giving the  boat a speed  of 2
  millimeters per  millisecond.  It  will then  get 5  milliseconds to
  move, reaching a total distance of 10 millimeters.
- Hold  the  button   for  3  milliseconds.  After   its  remaining  4
  milliseconds of travel time, the boat will have gone 12 millimeters.
- Hold  the  button   for  4  milliseconds.  After   its  remaining  3
  milliseconds of travel time, the boat will have gone 12 millimeters.
- Hold the  button for 5  milliseconds, causing  the boat to  travel a
  total of 10 millimeters.
- Hold the  button for 6  milliseconds, causing  the boat to  travel a
  total of 6 millimeters.
- Hold the  button for 7  milliseconds. That's the entire  duration of
  the race. You never let go of  the button. The boat can't move until
  you let you of the button. Please make sure you let go of the button
  so the boat gets to move. 0 millimeters.
  
Since the  current record for  this race  is 9 millimeters,  there are
actually 4 different ways you could win: you could hold the button for
2, 3, 4, or 5 milliseconds at the start of the race.

In  the  second  race, you  could  hold  the  button  for at  least  4
milliseconds and at most 11 milliseconds  and beat the record, a total
of 8 different ways to win.

In  the  third  race, you  could  hold  the  button  for at  least  11
milliseconds  and no  more than  19  milliseconds and  still beat  the
record, a total of 9 ways you could win.

To see how much margin of error you have, determine the number of ways
you can beat the record in each race; in this example, if you multiply
these values together, you get 288 (4 * 8 * 9).

Determine  the number  of  ways  you could  beat  the  record in  each
race. What do you get if you multiply these numbers together?

#+begin_src fennel :session day06
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn time2distance [time speed]
  (* time speed))

(fn race2distance [time]
  (fcollect [charge 0 time 1]
    (time2distance (- time charge) charge)))

(fn find-wins [input]
  (let [result []]
    (each [_ [time record] (ipairs input)]
      (table.insert result
                    (lume.reduce
                     (race2distance time)
                     (fn [acc x] (if (> x record) (+ acc 1) acc)))))
    result))

(fn count-wins [wins]
  (accumulate [prod 1
               _ win (ipairs wins)]
    (* prod win)))

(fn test-input [input]
  (let [wins (find-wins input)]
    (assert (= 288 (count-wins wins)))))

(test-input [[7 9] [15 40] [30 200]])

(fn lines-to-array [lines]
  [(lume.map (aoc.string-split (. lines 1) " ") #(tonumber $))
   (lume.map (aoc.string-split (. lines 2) " ") #(tonumber $))])

(fn real-input [lines]
  (let [[i1 i2] (lines-to-array lines)
        input (aoc.table-zip i1 i2)]
    (count-wins (find-wins input))))

(real-input (aoc.string-from "2023/06.inp"))
#+end_src

#+RESULTS:
: 4811940

* DONE Day 6.2
As the  race is about  to start, you realize  the piece of  paper with
race times and record distances you got earlier actually just has very
bad kerning. There's really only one  race - ignore the spaces between
the numbers on each line.

So, the example from before:
#+begin_example
Time:      7  15   30
Distance:  9  40  200
#+end_example

...now instead means this:
#+begin_example
Time:      71530
Distance:  940200
#+end_example

Now, you have to figure out how many ways there are to win this single
race. In this  example, the race lasts for 71530  milliseconds and the
record distance you need to beat is 940200 millimeters. You could hold
the button anywhere from 14 to 71516 milliseconds and beat the record,
a total of 71503 ways!

How many ways can you beat the record in this one much longer race?

#+begin_src fennel :session day06
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn test-input-p2 [input]
  (let [wins (find-wins input)]
    (assert (= 71503 (count-wins wins)))))

(test-input-p2 [[71530 940200]])

(fn lines-to-string [lines]
  (let [time (string.gsub (string.gsub (. lines 1) " *" "") "Time:" "")
        distance (string.gsub (string.gsub (. lines 2) " *" "") "Distance:" "")]
    [(tonumber time)
     (tonumber distance)]))

(fn real-input [lines]
  (let [input [(lines-to-string lines)]]
    (count-wins (find-wins input))))

(real-input (aoc.string-from "2023/06.inp"))
#+end_src

#+RESULTS:
: 30077773

* DONE Day 7.1
Your all-expenses-paid  trip turns  out to  be a  one-way, five-minute
ride in an airship.  (At least it's a cool airship!)  It drops you off
at the edge of a vast desert and descends back to Island Island.

"Did you bring the parts?"

You turn  around to see an  Elf completely covered in  white clothing,
wearing goggles, and riding a large camel.

"Did you  bring the parts?"   she asks  again, louder this  time.  You
aren't sure  what parts she's looking  for; you're here to  figure out
why the sand stopped.

"The parts!  For the sand,  yes! Come with me;  I will show  you." She
beckons you onto the camel.

After riding a bit across the sands of Desert Island, you can see what
look  like very  large rocks  covering half  of the  horizon. The  Elf
explains that the  rocks are all along the part  of Desert Island that
is  directly  above  Island  Island,   making  it  hard  to  even  get
there. Normally,  they use big machines  to move the rocks  and filter
the  sand, but  the machines  have broken  down because  Desert Island
recently stopped receiving the parts they need to fix the machines.

You've already assumed  it'll be your job to figure  out why the parts
stopped when she asks if you can help. You agree automatically.

Because the journey will take a few  days, she offers to teach you the
game of  Camel Cards. Camel Cards  is sort of similar  to poker except
it's designed to be easier to play while riding a camel.

In Camel  Cards, you get a  list of hands,  and your goal is  to order
them based on the strength of each hand. A hand consists of five cards
labeled one of A, K, Q, J, T, 9,  8, 7, 6, 5, 4, 3, or 2. The relative
strength of each card follows this order, where A is the highest and 2
is the lowest.

Every hand is exactly one type. From strongest to weakest, they are:
- Five of a kind, where all five cards have the same label: AAAAA
- Four of a kind, where four cards have the same label and one card
  has a different label: AA8AA
- Full house, where three cards have the same label, and the remaining
  two cards share a different label: 23332
- Three of a kind, where three cards have the same label, and the
  remaining two cards are each different from any other card in the
  hand: TTT98
- Two pair, where two cards share one label, two other cards share a
  second label, and the remaining card has a third label: 23432
- One pair, where two cards share one label, and the other three cards
  have a different label from the pair and each other: A23A4
- High card, where all cards' labels are distinct: 23456

Hands are  primarily ordered  based on type;  for example,  every full
house is stronger than any three of a kind.

If  two  hands have  the  same  type,  a  second ordering  rule  takes
effect. Start by comparing the first card in each hand. If these cards
are different,  the hand  with the stronger  first card  is considered
stronger. If the first card in each hand have the same label, however,
then move  on to  considering the  second card in  each hand.  If they
differ, the hand with the higher second card wins; otherwise, continue
with the third card in each hand, then the fourth, then the fifth.

So,  33332 and  2AAAA are  both four  of a  kind hands,  but 33332  is
stronger  because its  first card  is stronger.  Similarly, 77888  and
77788 are both  a full house, but 77888 is  stronger because its third
card is stronger (and both hands have the same first and second card).

To  play  Camel  Cards, you  are  given  a  list  of hands  and  their
corresponding bid (your puzzle input). For example:
#+begin_example
32T3K 765
T55J5 684
KK677 28
KTJJT 220
QQQJA 483
#+end_example

This  example shows  five  hands; each  hand is  followed  by its  bid
amount. Each  hand wins an amount  equal to its bid  multiplied by its
rank, where the weakest hand gets rank 1, the second-weakest hand gets
rank 2,  and so on  up to the strongest  hand. Because there  are five
hands in this example, the strongest hand will have rank 5 and its bid
will be multiplied by 5.

So, the first step is to put the hands in order of strength:
- 32T3K is the only one pair and the other hands are all a stronger
  type, so it gets rank 1.
- KK677 and KTJJT are both two pair. Their first cards both have the
  same label, but the second card of KK677 is stronger (K vs T), so
  KTJJT gets rank 2 and KK677 gets rank 3.
- T55J5 and QQQJA are both three of a kind. QQQJA has a stronger first
  card, so it gets rank 5 and T55J5 gets rank 4.
  
Now, you  can determine  the total  winnings of this  set of  hands by
adding up  the result  of multiplying  each hand's  bid with  its rank
(765 *  1 +  220 * 2  + 28 *  3 +  684 * 4  + 483 *  5). So  the total
winnings in this example are 6440.

Find the rank of every hand in your set. What are the total winnings?

#+begin_src fennel :session day07
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn all-wins [hands]
  (accumulate [sum 0 rank hand (ipairs hands)]
    (+ sum (* rank (. hand :bid)))))

(fn hand2type [hand]
  (case (aoc.string-toarray hand)
    ;; five of a kind
    [a a a a a] :t7
    ;; four of a kind
    [a b b b b] :t6
    [b a b b b] :t6
    [b b a b b] :t6
    [b b b a b] :t6
    [b b b b a] :t6
    ;; full house
    [a a a b b] :t5
    [a a b a b] :t5
    [a b a a b] :t5
    [b a a a b] :t5
    [b a a b a] :t5
    [b a b a a] :t5
    [b b a a a] :t5
    [a b b a a] :t5
    [a a b b a] :t5
    [a b a b a] :t5
    ;; three of a kind
    [b c a a a] :t4
    [b a c a a] :t4
    [b a a c a] :t4
    [b a a a c] :t4
    [a b a a c] :t4
    [a a b a c] :t4
    [a a a b c] :t4
    [a b c a a] :t4
    [a a b c a] :t4
    [a b a c a] :t4
    ;; two pairs
    [a a b b c] :t3
    [a a b c b] :t3
    [a a c b b] :t3
    [a c a b b] :t3
    [c a a b b] :t3
    [a b a b c] :t3
    [a b a c b] :t3
    [a b c a b] :t3
    [a c b a b] :t3
    [c a b a b] :t3
    [a b b a c] :t3
    [a b b c a] :t3
    [a b c b a] :t3
    [a c b b a] :t3
    [c a b b a] :t3
    ;; one pair
    [a a b c d] :t2
    [a b a c d] :t2
    [a b c a d] :t2
    [a b c d a] :t2
    [b a c d a] :t2
    [b c a d a] :t2
    [b c d a a] :t2
    [b a a c d] :t2
    [b c a a d] :t2
    [b a c a d] :t2
    ;; high card
    [a b c d e] :t1))

(fn hand2number [hand]
  (accumulate [sum 0 i x (ipairs (aoc.table-reverse (aoc.string-toarray hand)))]
    (+ sum (* (^ 100 (- i 1))
              (case x
                "A" 14
                "K" 13
                "Q" 12
                "J" 11
                "T" 10
                "9" 9
                "8" 8
                "7" 7
                "6" 6
                "5" 5
                "4" 4
                "3" 3
                "2" 2)))))

(fn test-hand2number []
  (assert (= 1212121114 (hand2number "QQQJA")))
  (assert (= 1414141414 (hand2number "AAAAA")))
  (assert (= 202020202 (hand2number "22222")))
  (assert (= 1313060707 (hand2number "KK677")))
  (assert (= 1310111110 (hand2number "KTJJT"))))

(test-hand2number)

(fn numeric-comp [a b]
  (let [an (hand2number (. a :hand))
        bn (hand2number (. b :hand))]
    (< an bn)))

(fn test-numeric-comp []
  (assert (numeric-comp {:hand "QQQJA"} {:hand "AAAAA"}))
  (assert (not (numeric-comp {:hand "AAAAA"} {:hand "QQQJA"})))
  (assert (numeric-comp {:hand "22222"} {:hand "QQQJA"}))
  (assert (not (numeric-comp {:hand "QQQJA"} {:hand "22222"})))
  (assert (not (numeric-comp {:hand "KK677"} {:hand "KTJJT"}))))

(test-numeric-comp)

(fn table.join [xs ys]
  (table.sort ys numeric-comp)
  (table.move ys 1 (length ys) (+ 1 (length xs)) xs))

(fn all-hands [lines]
  (let [t7 [] t6 [] t5 [] t4 [] t3 [] t2 [] t1 [] allhands []]
    (each [_ line (ipairs lines)]
      (let [[hand bid] (aoc.string-split line " ")]
        (case (hand2type hand)
          "t7" (table.insert t7 {:hand hand :bid (tonumber bid)})
          "t6" (table.insert t6 {:hand hand :bid (tonumber bid)})
          "t5" (table.insert t5 {:hand hand :bid (tonumber bid)})
          "t4" (table.insert t4 {:hand hand :bid (tonumber bid)})
          "t3" (table.insert t3 {:hand hand :bid (tonumber bid)})
          "t2" (table.insert t2 {:hand hand :bid (tonumber bid)})
          "t1" (table.insert t1 {:hand hand :bid (tonumber bid)}))))
    (table.join allhands t1)
    (table.join allhands t2)
    (table.join allhands t3)
    (table.join allhands t4)
    (table.join allhands t5)
    (table.join allhands t6)
    (table.join allhands t7)
    allhands))

(fn find-score [lines]
  (let [hands (all-hands lines)]
    (all-wins hands)))

(fn test-input [expected lines]
  (let [score (find-score lines)]
    (assert (= expected score) score)))

(test-input 6440
            ["32T3K 765" 
             "T55J5 684"
             "KK677 28"
             "KTJJT 220"
             "QQQJA 483"])

(test-input 201
            ["AAATK 1"
             "TTTAA 100"])

(test-input 10
            ["23456 1"
             "AAAKK 3"
             "AAAAA 1"])

(test-input 6592
            ["2345A 1"
             "Q2KJJ 13"
             "Q2Q2Q 19"
             "T3T3J 17"
             "T3Q33 11"
             "2345J 3"
             "J345A 2"
             "32T3K 5"
             "T55J5 29"
             "KK677 7"
             "KTJJT 34"
             "QQQJA 31"
             "JJJJJ 37"
             "JAAAA 43"
             "AAAAJ 59"
             "AAAAA 61"
             "2AAAA 23"
             "2JJJJ 53"
             "JJJJ2 41"])

(find-score (aoc.string-from "2023/07.inp"))
#+end_src

#+RESULTS:
: 251545216

* DONE Day 8.1
You're  still riding  a camel  across Desert  Island when  you spot  a
sandstorm  quickly approaching.  When you  turn to  warn the  Elf, she
disappears before your eyes! To be fair, she had just finished warning
you about ghosts a few minutes ago.

One of the camel's pouches is  labeled "maps" - sure enough, it's full
of documents (your puzzle input) about  how to navigate the desert. At
least, you're pretty  sure that's what they are; one  of the documents
contains  a list  of  left/right  instructions, and  the  rest of  the
documents seem to describe some kind of network of labeled nodes.

It  seems like  you're meant  to  use the  left/right instructions  to
navigate the  network. Perhaps if you  have the camel follow  the same
instructions, you can escape the haunted wasteland!

After  examining the  maps for  a bit,  two nodes  stick out:  AAA and
ZZZ. You feel  like AAA is where  you are now, and you  have to follow
the left/right instructions until you reach ZZZ.

This format defines each node of the network individually. For example:
#+begin_example
RL

AAA = (BBB, CCC)
BBB = (DDD, EEE)
CCC = (ZZZ, GGG)
DDD = (DDD, DDD)
EEE = (EEE, EEE)
GGG = (GGG, GGG)
ZZZ = (ZZZ, ZZZ)
#+end_example

Starting with AAA, you  need to look up the next  element based on the
next left/right instruction in your input. In this example, start with
AAA and go right (R) by choosing  the right element of AAA, CCC. Then,
L  means to  choose the  left element  of CCC,  ZZZ. By  following the
left/right instructions, you reach ZZZ in 2 steps.

Of  course, you  might not  find ZZZ  right away.  If you  run out  of
left/right instructions, repeat the  whole sequence of instructions as
necessary: RL really means RLRLRLRLRLRLRLRL... and so on. For example,
here is a situation that takes 6 steps to reach ZZZ:
#+begin_example
LLR

AAA = (BBB, BBB)
BBB = (AAA, ZZZ)
ZZZ = (ZZZ, ZZZ)
#+end_example

Starting at AAA, follow the left/right instructions. How many steps
are required to reach ZZZ?

#+begin_src fennel :session day08
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn read-node [line]
  [(string.sub line 1 3)
   (string.sub line 8 10)
   (string.sub line 13 15)])

(fn read-nodes [lines]
  (let [map {}]
    (each [_ line (ipairs lines)]
      (let [[start left right] (read-node line)]
        (tset map start [left right])))
    map))

(local path "LRLLRRRLRRLRRRLRLRRLLRRLRRLRRLRRRLLRRLRRLLLRRLLRRRLRRRLRRRLRLRRRLRRRLRLRLRRLRLRRRLRLRLRRRLLRRRLRLRRLLLRRRLLRRLLLRRRLRRLLRLRLRRRLRRLLRRLRRRLRRRLLRRRLLRRRLRRLRRLRLRRRLLLRRRLRRRLRLRRLRRLRRLRRLRRLRRRLRRRLRRLLRRLRRRLRLLRLLRRLLRRLRRRLRRRLRRRLRRRLRRLRRRLLRRLRRRLRRLRRRLRRLRRLRRLRRLRRLRLRRRR")

(fn path-find [map start end path step]
  (if (= end start) step
      (case (string.sub path 1 1)
        "R" (path-find map (. (. map start) 2) end (aoc.string-pushback path) (+ 1 step))
        "L" (path-find map (. (. map start) 1) end (aoc.string-pushback path) (+ 1 step)))))

(fn test-input [lines expected path]
  (let [map (read-nodes lines)]
    (assert (= expected (path-find map "AAA" "ZZZ" path  0)))))

(local test-input-1
       ["AAA = (BBB, CCC)"
        "BBB = (DDD, EEE)"
        "CCC = (ZZZ, GGG)"
        "DDD = (DDD, DDD)"
        "EEE = (EEE, EEE)"
        "GGG = (GGG, GGG)"
        "ZZZ = (ZZZ, ZZZ)"])

(test-input test-input-1 2 "RL")

(local test-input-2
       ["AAA = (BBB, BBB)"
        "BBB = (AAA, ZZZ)"
        "ZZZ = (ZZZ, ZZZ)"])

(test-input test-input-2 6 "LLR")

(fn real-input [lines path]
  (let [map (read-nodes lines)]
    (path-find map "AAA" "ZZZ" path 0)))

(real-input (aoc.string-from "2023/08.inp") path)
#+end_src

#+RESULTS:
: 20093

* DONE Day 8.2
The sandstorm  is upon you and  you aren't any closer  to escaping the
wasteland.  You had  the  camel follow  the  instructions, but  you've
barely left your  starting position. It's going  to take significantly
more steps to escape!

What if the map isn't for people -  what if the map is for ghosts? Are
ghosts even bound by the laws of spacetime? Only one way to find out.

After examining  the maps a bit  longer, your attention is  drawn to a
curious fact: the number  of nodes with names ending in  A is equal to
the number ending in Z! If you were a ghost, you'd probably just start
at every node that ends with A and follow all of the paths at the same
time until they all simultaneously end up at nodes that end with Z.

For example:
#+begin_example
LR

11A = (11B, XXX)
11B = (XXX, 11Z)
11Z = (11B, XXX)
22A = (22B, XXX)
22B = (22C, 22C)
22C = (22Z, 22Z)
22Z = (22B, 22B)
XXX = (XXX, XXX)
#+end_example

Here, there are two starting nodes, 11A and 22A (because they both end
with  A).  As  you  follow   each  left/right  instruction,  use  that
instruction  to simultaneously  navigate away  from both  nodes you're
currently  on. Repeat  this  process  until all  of  the nodes  you're
currently on end with Z. (If only some of the nodes you're on end with
Z, they act like  any other node and you continue  as normal.) In this
example, you would proceed as follows:
- Step 0: You are at 11A and 22A.
- Step 1: You choose all of the left paths, leading you to 11B and 22B.
- Step 2: You choose all of the right paths, leading you to 11Z and 22C.
- Step 3: You choose all of the left paths, leading you to 11B and 22Z.
- Step 4: You choose all of the right paths, leading you to 11Z and 22B.
- Step 5: You choose all of the left paths, leading you to 11B and 22C.
- Step 6: You choose all of the right paths, leading you to 11Z and 22Z.

So, in this example, you end up  entirely on nodes that end in Z after
6 steps.

Simultaneously start  on every node that  ends with A. How  many steps
does it take before you're only on nodes that end with Z?

#+begin_src fennel :session day08
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn paths-find [desert start end path step]
  (if (aoc.table-identical? start end) step
      (let [newstart (case (string.sub path 1 1)
                       "R" (lume.map start #(. (. desert $) 2))
                       "L" (lume.map start #(. (. desert $) 1)))]
        (paths-find desert newstart end (aoc.string-pushback path) (+ 1 step)))))

(fn test-inputp2 [lines expected]
  (let [map (read-nodes lines)]
    (assert (= expected (paths-find map ["11A" "22A"] ["11Z" "22Z"] "LR" 0)))))

(local test-input-p2
       ["11A = (11B, XXX)"
        "11B = (XXX, 11Z)"
        "11Z = (11B, XXX)"
        "22A = (22B, XXX)"
        "22B = (22C, 22C)"
        "22C = (22Z, 22Z)"
        "22Z = (22B, 22B)"
        "XXX = (XXX, XXX)"])

(test-inputp2 test-input-p2 6)

(fn path-to-any [map start end path step]
  (if (aoc.table-contains? end start) step
      (let [newstart (case (string.sub path 1 1)
                       "R" (. (. map start) 2) 
                       "L" (. (. map start) 1))]
        (path-to-any map newstart end (aoc.string-pushback path) (+ 1 step)))))

(fn p2-input [lines]
  (let [map (read-nodes lines)
        start ["VGA" "AAA" "LHA" "RHA" "CVA" "LDA"]
        end ["BKZ" "KJZ" "XNZ" "XLZ" "PQZ" "ZZZ"]]
    (lume.map start #(path-to-any map $ end path 0))))

(fn real-input [lines]
  (lume.reduce (p2-input lines) aoc.math-lcm))

(real-input (aoc.string-from "2023/08.inp"))
#+end_src

#+RESULTS:
: 22103062509257

* DONE Day 9.1
You ride  the camel through the  sandstorm and stop where  the ghost's
maps told  you to stop.  The sandstorm subsequently  subsides, somehow
seeing you standing at an oasis!

The camel  goes to get  some water and you  stretch your neck.  As you
look up, you discover what must  be yet another giant floating island,
this one made of  metal! That must be where the parts  to fix the sand
machines come from.

There's even a hang glider partially buried in the sand here; once the
sun rises and heats  up the sand, you might be able  to use the glider
and the hot air to get all the way up to the metal island!

While you wait for  the sun to rise, you admire  the oasis hidden here
in the middle of Desert Island. It must have a delicate ecosystem; you
might as well take some ecological  readings while you wait. Maybe you
can report any environmental instabilities  you find to someone so the
oasis can be around for the next sandstorm-worn traveler.

You pull out your handy Oasis  And Sand Instability Sensor and analyze
your surroundings. The OASIS produces a  report of many values and how
they are  changing over  time (your  puzzle input).  Each line  in the
report contains the history of a single value. For example:

#+begin_example
0 3 6 9 12 15
1 3 6 10 15 21
10 13 16 21 30 45
#+end_example

To best protect the oasis,  your environmental report should include a
prediction of  the next value  in each history.  To do this,  start by
making  a new  sequence  from  the difference  at  each  step of  your
history.  If that  sequence is  not all  zeroes, repeat  this process,
using the sequence you just generated  as the input sequence. Once all
of the values in your latest  sequence are zeroes, you can extrapolate
what the next value of the original history should be.

In the above dataset, the first history is  0 3 6 9 12 15. Because the
values increase by 3 each step, the first sequence of differences that
you generate will be 3 3 3 3  3. Note that this sequence has one fewer
value than  the input sequence because  at each step it  considers two
numbers from the input. Since these values aren't all zero, repeat the
process: the values differ by 0 at  each step, so the next sequence is
0 0  0 0. This  means you have  enough information to  extrapolate the
history! Visually, these sequences can be arranged like this:

#+begin_example
0   3   6   9  12  15
  3   3   3   3   3
    0   0   0   0
#+end_example

To extrapolate, start by adding a new  zero to the end of your list of
zeroes;  because  the zeroes  represent  differences  between the  two
values above them, this also means there is now a placeholder in every
sequence above it:

#+begin_example
0   3   6   9  12  15   B
  3   3   3   3   3   A
    0   0   0   0   0
#+end_example

You can then start filling in placeholders from the bottom up. A needs
to be  the result of increasing  3 (the value  to its left) by  0 (the
value below it); this means A must be 3:

#+begin_example
0   3   6   9  12  15   B
  3   3   3   3   3   3
    0   0   0   0   0
#+end_example

Finally, you can fill in B, which needs to be the result of increasing
15 (the value to its left) by 3 (the value below it), or 18:

#+begin_example
0   3   6   9  12  15  18
  3   3   3   3   3   3
    0   0   0   0   0
#+end_example

So, the next value of the first history is 18.

Finding  all-zero  differences  for  the second  history  requires  an
additional sequence:
#+begin_example
1   3   6  10  15  21
  2   3   4   5   6
    1   1   1   1
      0   0   0
#+end_example

Then, following the same process as before, work out the next value in
each sequence from the bottom up:
#+begin_example
1   3   6  10  15  21  28
  2   3   4   5   6   7
    1   1   1   1   1
      0   0   0   0
#+end_example

So, the next value of the second history is 28.

The third history requires even more sequences, but its next value can
be found the same way:
#+begin_example
10  13  16  21  30  45  68
   3   3   5   9  15  23
     0   2   4   6   8
       2   2   2   2
         0   0   0
#+end_example

So, the next value of the third history is 68.

If you find  the next value for  each history in this  example and add
them together, you get 114.

Analyze your OASIS report and extrapolate the next value for each
history. What is the sum of these extrapolated values?

#+begin_src fennel :session day09
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn table-zip [t1 t2 f]
  (assert (= (length t1)
             (length t2)))
  (let [result []]
    (for [i 1 (length t1) 1]
      (table.insert result (f (. t1 i) (. t2 i))))
    result))

(fn table.dec [t]
  (let [t1 (aoc.table-range t 2 (length t))
        t2 (aoc.table-range t 1 (- (length t) 1))]
    (table-zip t1 t2 (fn [a b] (- a b)))))

(fn derive [t]
  (var dt t)
  (let [result [dt]]
    (while (not (aoc.table-zero? dt))
      (set dt (table.dec dt))
      (table.insert result dt))
    result))

(fn solve [t]
  (let [result []]
    (each [_ ti (ipairs t)]
      (table.insert result (aoc.last ti)))
    (aoc.table-sum result)))

(fn read-input [lines]
  (let [input []]
    (each [_ line (ipairs lines)]
      (table.insert input (lume.map (aoc.string-split line " ") #(tonumber $))))
    input))

(fn test-input [lines expected]
  (let [input (read-input lines)]
    (assert (= expected (aoc.table-sum (lume.map input #(solve (derive $))))))))

(local test-input-1 [" 0  3  6  9 12 15"
                     " 1  3  6 10 15 21"
                     "10 13 16 21 30 45"])

(test-input test-input-1 114)

(fn real-input [lines]
  (let [input (read-input lines)]
    (aoc.table-sum (lume.map input #(solve (derive $))))))

(real-input (aoc.string-from "2023/09.inp"))
#+end_src

#+RESULTS:
: 1702218515

* DONE Day 9.2
Of course, it would be nice to have even more history included in your
report. Surely it's safe to just extrapolate backwards as well, right?

For each history, repeat the  process of finding differences until the
sequence of differences  is entirely zero. Then, rather  than adding a
zero  to the  end and  filling  in the  next values  of each  previous
sequence,  you should  instead add  a zero  to the  beginning of  your
sequence of  zeroes, then fill in  new first values for  each previous
sequence.

In particular, here is what the  third example history looks like when
extrapolating back in time:

#+begin_example
5  10  13  16  21  30  45
  5   3   3   5   9  15
   -2   0   2   4   6
      2   2   2   2
        0   0   0
#+end_example

Adding the new values on the left side of each sequence from bottom to
top eventually reveals the new left-most history value: 5.

Doing this  for the remaining  example data above results  in previous
values  of   -3  for  the   first  history   and  0  for   the  second
history. Adding all three new values together produces 2.

Analyze your OASIS report again,  this time extrapolating the previous
value for each history. What is the sum of these extrapolated values?

#+begin_src fennel :session day09
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn test-inputp2 [lines expected]
  (let [input (read-input lines)]
    (assert (= expected (aoc.table-sum (lume.map input #(solve (derive (aoc.table-reverse $)))))))))

(test-inputp2 test-input-1 2)

(fn real-input [lines]
  (let [input (read-input lines)]
    (aoc.table-sum (lume.map input #(solve (derive (aoc.table-reverse $)))))))

(real-input (aoc.string-from "2023/09.inp"))
#+end_src

#+RESULTS:
: 925

* DONE Day 10.1
You use the hang glider to ride the hot air from Desert Island all the
way up to the floating metal  island. This island is surprisingly cold
and there  definitely aren't any  thermals to  glide on, so  you leave
your hang glider behind.

You  wander around  for a  while,  but you  don't find  any people  or
animals.  However, you  do  occasionally find  signposts labeled  "Hot
Springs" pointing in  a seemingly consistent direction;  maybe you can
find someone at the hot springs  and ask them where the desert-machine
parts are made.

The landscape  here is alien; even  the flowers and trees  are made of
metal. As  you stop to admire  some metal grass, you  notice something
metallic scurry  away in your  peripheral vision  and jump into  a big
pipe! It didn't look  like any animal you've ever seen;  if you want a
better look, you'll need to get ahead of it.

Scanning the area, you discover  that the entire field you're standing
on is densely packed with pipes; it  was hard to tell at first because
they're the  same metallic silver  color as  the "ground". You  make a
quick sketch  of all  of the  surface pipes you  can see  (your puzzle
input).

The pipes are arranged in a two-dimensional grid of tiles:
- | is a vertical pipe connecting north and south.
- - is a horizontal pipe connecting east and west.
- L is a 90-degree bend connecting north and east.
- J is a 90-degree bend connecting north and west.
- 7 is a 90-degree bend connecting south and west.
- F is a 90-degree bend connecting south and east.
- . is ground; there is no pipe in this tile.
- S is the starting position of the animal; there is a pipe on this
  tile, but your sketch doesn't show what shape the pipe has.
  
Based on the acoustics of the animal's scurrying, you're confident the
pipe that contains the animal is one large, continuous loop.

For example, here is a square loop of pipe:
#+begin_example
.....
.F-7.
.|.|.
.L-J.
.....
#+end_example

If  the animal  had entered  this loop  in the  northwest corner,  the
sketch would instead look like this:
#+begin_example
.....
.S-7.
.|.|.
.L-J.
.....
#+end_example

In the above diagram, the S tile  is still a 90-degree F bend: you can
tell because of how the adjacent pipes connect to it.


Unfortunately, there are also many  pipes that aren't connected to the
loop! This sketch shows the same loop as above:
#+begin_example
-L|F7
7S-7|
L|7||
-L-J|
L|-JF
#+end_example

In the  above diagram, you can  still figure out which  pipes form the
main loop: they're the ones connected  to S, pipes those pipes connect
to, pipes those  pipes connect to, and  so on. Every pipe  in the main
loop  connects to  its two  neighbors  (including S,  which will  have
exactly two  pipes connecting to it,  and which is assumed  to connect
back to those two pipes).

Here is a sketch that contains a slightly more complex main loop:
#+begin_example
..F7.
.FJ|.
SJ.L7
|F--J
LJ...
#+end_example

Here's the same example sketch with the extra, non-main-loop pipe
tiles also shown:
#+begin_example
7-F7-
.FJ|7
SJLL7
|F--J
LJ.LJ
#+end_example

If you want to  get out ahead of the animal, you  should find the tile
in the loop  that is farthest from the starting  position. Because the
animal is in the pipe, it doesn't make sense to measure this by direct
distance.  Instead, you  need to  find the  tile that  would take  the
longest number  of steps  along the  loop to  reach from  the starting
point - regardless of which way around the loop the animal went.

In the first example with the square loop:
#+begin_example
.....
.S-7.
.|.|.
.L-J.
.....
#+end_example

You can count the distance each tile in the loop is from the starting
point like this:
#+begin_example
.....
.012.
.1.3.
.234.
.....
#+end_example

In this example, the farthest point from the start is 4 steps away.

Here's the more complex loop again:
#+begin_example
..F7.
.FJ|.
SJ.L7
|F--J
LJ...
#+end_example

Here are the distances for each tile on that loop:
#+begin_example
..45.
.236.
01.78
14567
23...
#+end_example

Find the  single giant loop  starting at S.  How many steps  along the
loop  does it  take to  get from  the starting  position to  the point
farthest from the starting position?

#+begin_src fennel :session day10
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(local S2N ["|" "F" "7" "S"])
(local N2S ["|" "L" "J" "S"])
(local E2W ["-" "L" "F" "S"])
(local W2E ["-" "7" "J" "S"])

(fn connected? [t x y dir]
  (case dir
    :north (aoc.table-contains? S2N (?. (?. t (- x 1)) y))
    :east (aoc.table-contains? W2E (?. (?. t x) (+ 1 y)))
    :south (aoc.table-contains? N2S (?. (?. t (+ x 1)) y))
    :west (aoc.table-contains? E2W (?. (?. t x) (- y 1)))))

(fn move [t x y s from]
  (let [pos (. (. t x) y)]
    (if (and (< 0 s) (= "S" pos)) (aoc.int (/ s 2))
        (< (* (length t) (length (. t 1))) s) -1
        (case pos
          "S" (if (connected? t x y :north) (move t (- x 1) y (+ 1 s) :south)
                  (connected? t x y :east) (move t x (+ y 1) (+ 1 s) :west)
                  (connected? t x y :south) (move t (+ x 1) y (+ 1 s) :north)
                  (connected? t x y :west) (move t x (- y 1) (+ 1 s) :east))
          "-" (case from
                :west (if (connected? t x y :east) (move t x (+ y 1) (+ 1 s) :west))
                :east (if (connected? t x y :west) (move t x (- y 1) (+ 1 s) :east)))
          "|" (case from
                :south (if (connected? t x y :north) (move t (- x 1) y (+ 1 s) :south))
                :north (if (connected? t x y :south) (move t (+ x 1) y (+ 1 s) :north)))
          "F" (case from
                :south (if (connected? t x y :east) (move t x (+ y 1) (+ 1 s) :west))
                :east (if (connected? t x y :south) (move t (+ x 1) y (+ 1 s) :north)))
          "L" (case from
                :east (if (connected? t x y :north) (move t (- x 1) y (+ 1 s) :south))
                :north (if (connected? t x y :east) (move t x (+ y 1) (+ 1 s) :west)))
          "7" (case from
                :west (if (connected? t x y :south) (move t (+ x 1) y (+ 1 s) :north))
                :south (if (connected? t x y :west) (move t x (- y 1) (+ 1 s) :east)))
          "J" (case from
                :west (if (connected? t x y :north) (move t (- x 1) y (+ 1 s) :south))
                :north (if (connected? t x y :west) (move t x (- y 1) (+ 1 s) :east)))))))

(fn test-input [expected input sx sy]
  (assert (= expected (move input sx sy 0 :start))))

(test-input 4
            [(aoc.string-toarray "-L|F7")
             (aoc.string-toarray "7S-7|")
             (aoc.string-toarray "L|7||")
             (aoc.string-toarray "-L-J|")
             (aoc.string-toarray "L|-JF")]
            2 2)

(test-input 8
            [(aoc.string-toarray "7-F7-")
             (aoc.string-toarray ".FJ|7")
             (aoc.string-toarray "SJLL7")
             (aoc.string-toarray "|F--J")
             (aoc.string-toarray "LJ.LJ")]
            3 1)

(fn real-input [lines]
  (let [input (aoc.read-matrix lines)]
    (move input 64 63 0 :start)))

(real-input (aoc.string-from "2023/10.inp"))
#+end_src

#+RESULTS:
: 7093

* DONE Day 11.1
You continue  following signs  for "Hot  Springs" and  eventually come
across an  observatory. The Elf  within turns  out to be  a researcher
studying cosmic expansion using the giant telescope here.

He doesn't  know anything about  the missing machine parts;  he's only
visiting for this research project.  However, he confirms that the hot
springs are  the next-closest area  likely to have people;  he'll even
take  you  straight there  once  he's  done with  today's  observation
analysis.

Maybe you can help him with the analysis to speed things up?

The researcher  has collected a  bunch of  data and compiled  the data
into  a single  giant image  (your puzzle  input). The  image includes
empty space (.) and galaxies (#). For example:

#+begin_example
...#......
.......#..
#.........
..........
......#...
.#........
.........#
..........
.......#..
#...#.....
#+end_example

The researcher is trying  to figure out the sum of  the lengths of the
shortest  path between  every  pair of  galaxies.  However, there's  a
catch: the universe expanded in the  time it took the light from those
galaxies to reach the observatory.

Due  to something  involving  gravitational effects,  only some  space
expands. In fact, the result is  that any rows or columns that contain
no galaxies should all actually be twice as big.

In the above example, three columns and two rows contain no galaxies:
#+begin_example
   v  v  v
 ...#......
 .......#..
 #.........
>..........<
 ......#...
 .#........
 .........#
>..........<
 .......#..
 #...#.....
   ^  ^  ^
#+end_example

These rows and columns  need to be twice as big;  the result of cosmic
expansion therefore looks like this:
#+begin_example
....#........
.........#...
#............
.............
.............
........#....
.#...........
............#
.............
.............
.........#...
#....#.......
#+end_example


Equipped with this expanded universe,  the shortest path between every
pair of galaxies  can be found. It  can help to assign  every galaxy a
unique number:

#+begin_example
....1........
.........2...
3............
.............
.............
........4....
.5...........
............6
.............
.............
.........7...
8....9.......
#+end_example

In these  9 galaxies, there are  36 pairs. Only count  each pair once;
order within the pair doesn't matter. For each pair, find any shortest
path between  the two galaxies  using only  steps that move  up, down,
left,  or right  exactly one  . or  # at  a time.  (The shortest  path
between two galaxies is allowed to pass through another galaxy.)

For example, here is one of the shortest paths between galaxies 5 and 9:
#+begin_example
....1........
.........2...
3............
.............
.............
........4....
.5...........
.##.........6
..##.........
...##........
....##...7...
8....9.......
#+end_example

This path has length 9 because it takes a minimum of nine steps to get
from galaxy 5 to galaxy 9 (the  eight locations marked # plus the step
onto  galaxy 9  itself). Here  are  some other  example shortest  path
lengths:
- Between galaxy 1 and galaxy 7: 15
- Between galaxy 3 and galaxy 6: 17
- Between galaxy 8 and galaxy 9: 5

In this example, after expanding the universe, the sum of the shortest
path between all 36 pairs of galaxies is 374.

Expand the universe, then find the length of the shortest path between
every pair of galaxies. What is the sum of these lengths?

#+begin_src fennel :session day11
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn distance [a b]
  (let [[x1 y1] a [x2 y2] b]
    (+ (math.abs (- x1 x2)) (math.abs (- y1 y2)))))

(fn find-coords [matrix v]
  (let [result []]
    (for [i 1 (length matrix) 1]
      (for [j 1 (length (. matrix i)) 1]
        (when (= v (. (. matrix i) j))
          (table.insert result [i j]))))
    result))

(fn calculate-distances [xs]
  (let [result []]
    (for [i 1 (length xs) 1]
      (table.insert result 
                    (lume.map (aoc.table-range xs i (length xs)) #(distance (. xs i) $))))
    result))

(fn find-blank-rows [matrix blank]
  (let [result []]
    (each [i row (ipairs matrix)]
      (if (lume.all row #(= $ blank))
          (table.insert result i)))
    (aoc.table-reverse result)))

(fn expand-empty-space [matrix]
  (let [rows (find-blank-rows matrix ".")]
    (each [_ row (ipairs rows)]
      (table.insert matrix row (. matrix row))))
  (let [result (aoc.table-transpose matrix)
        rows (find-blank-rows result ".")]
    (each [_ row (ipairs rows)]
      (table.insert result row (. result row)))
    (aoc.table-transpose result)))

(fn test-input [matrix]
  (let [coords (find-coords matrix "#")
        distances (calculate-distances coords)]
    (assert (= 9 (. (. distances 5) (- 9 5 -1))))
    (assert (= 15 (. (. distances 1) (- 7 1 -1))))
    (assert (= 17 (. (. distances 3) (- 6 3 -1))))
    (assert (= 5 (. (. distances 8) (- 9 8 -1))))
    (assert (= 374 (aoc.table-sum distances)))))

(test-input
 (expand-empty-space
  (aoc.read-matrix
   ["...#......"
    ".......#.."
    "#........."
    ".........."
    "......#..."
    ".#........"
    ".........#"
    ".........."
    ".......#.."
    "#...#....."])))

(fn real-input [matrix]
  (let [coords (find-coords matrix "#")
        dist (calculate-distances coords)]
    (aoc.table-sum dist)))

(real-input (expand-empty-space (aoc.read-matrix (aoc.string-from "2023/11.inp"))))
#+end_src

#+RESULTS:
: 9965032

* DONE Day 14.1
You reach the place where all  of the mirrors were pointing: a massive
parabolic  reflector  dish  attached  to the  side  of  another  large
mountain.

The  dish is  made up  of many  small mirrors,  but while  the mirrors
themselves are  roughly in  the shape of  a parabolic  reflector dish,
each  individual mirror  seems to  be pointing  in slightly  the wrong
direction. If the  dish is meant to focus light,  all it's doing right
now is sending it in a vague direction.

This system  must be  what provides  the energy for  the lava!  If you
focus the reflector dish, maybe you can go where it's pointing and use
the light to fix the lava production.

Upon  closer inspection,  the  individual mirrors  each  appear to  be
connected via  an elaborate  system of  ropes and  pulleys to  a large
metal platform below the dish. The  platform is covered in large rocks
of  various shapes.  Depending on  their position,  the weight  of the
rocks deforms  the platform,  and the shape  of the  platform controls
which ropes move and ultimately the focus of the dish.

In short: if you move the rocks,  you can focus the dish. The platform
even has a control  panel on the side that lets you tilt  it in one of
four directions! The rounded rocks (O)  will roll when the platform is
tilted, while the  cube-shaped rocks (#) will stay in  place. You note
the positions  of all of the  empty spaces (.) and  rocks (your puzzle
input). For example:

#+begin_example
O....#....
O.OO#....#
.....##...
OO.#O....O
.O.....O#.
O.#..O.#.#
..O..#O..O
.......O..
#....###..
#OO..#....
#+end_example

Start by tilting the lever so all of the rocks will slide north as far
as they will go:

#+begin_example
OOOO.#.O..
OO..#....#
OO..O##..O
O..#.OO...
........#.
..#....#.#
..O..#.O.O
..O.......
#....###..
#....#....
#+end_example

You notice that the support beams along the north side of the platform
are  damaged; to  ensure  the platform  doesn't  collapse, you  should
calculate the total load on the north support beams.

The amount of load caused by a single rounded rock (O) is equal to the
number  of rows  from the  rock  to the  south edge  of the  platform,
including  the  row the  rock  is  on.  (Cube-shaped rocks  (#)  don't
contribute to  load.) So, the  amount of load  caused by each  rock in
each row is as follows:

#+begin_example
OOOO.#.O.. 10
OO..#....#  9
OO..O##..O  8
O..#.OO...  7
........#.  6
..#....#.#  5
..O..#.O.O  4
..O.......  3
#....###..  2
#....#....  1
#+end_example

The total  load is the sum  of the load  caused by all of  the rounded
rocks. In this example, the total load is 136.

Tilt the platform so that the rounded rocks all roll north. Afterward,
what is the total load on the north support beams?

#+begin_src fennel :session day14
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn table.swap [t i j direction]
  (let [ij (. (. t i) j)]
    (case direction
      :north (when (< 1 i)
               (let [old (aoc.table-replace t (- i 1) j ij)]
                 (aoc.table-replace t i j old)))
      :south (when (< i (length t))
               (let [old (aoc.table-replace t (+ i 1) j ij)]
                 (aoc.table-replace t i j old)))
      :east (when (< j (length (. t i)))
               (let [old (aoc.table-replace t i (+ j 1) ij)]
                 (aoc.table-replace t i j old)))
      :west (when (< 1 j)
               (let [old (aoc.table-replace t i (- j 1) ij)]
                 (aoc.table-replace t i j old)))))
  t)

(fn math.wsum [xs]
  (let [xx (aoc.table-reverse xs)]
    (accumulate [sum 0 i x (ipairs xx)]
      (+ sum (* i x)))))

(fn table.tonumbers [lines]
  (lume.map lines #(aoc.string-toarray $)))

(fn tilt-north [matrix]
  (let [len1 (length matrix)
        len2 (length (. matrix 1))]
    (for [i (- len1 1) 1 -1]
      (for [j len1 (+ i 1) -1]
        (for [k len2 1 -1]
          (when (and (= "O" (. (. matrix j) k))
                     (= "." (. (. matrix (- j 1)) k)))
            (table.swap matrix j k :north))))))
  matrix)

(fn tilt-south [matrix]
  matrix)

(fn tilt-east [matrix]
  matrix)

(fn tilt-west [matrix]
  matrix)

(fn tilt [matrix direction]
  (case direction
    :north (tilt-north (tilt-north (tilt-north matrix)))
    :south (tilt-south matrix)
    :east (tilt-east matrix)
    :west (tilt-west matrix)
    _ matrix))

(fn weight [xs]
  (var count 0)
  (each [_ x (ipairs xs)]
    (when (= "O" x)
      (set count (+ 1 count))))
  count)

(fn weights [xs]
  (lume.map xs #(weight $)))

(fn test-input [lines]
  (let [input (table.tonumbers lines) 
        matrix (tilt input :north)]
    (assert (= 136 (math.wsum (weights matrix))))))

(test-input ["O....#...."
             "O.OO#....#"
             ".....##..."
             "OO.#O....O"
             ".O.....O#."
             "O.#..O.#.#"
             "..O..#O..O"
             ".......O.."
             "#....###.."
             "#OO..#...."])

(fn real-input [lines]
  (let [input (table.tonumbers lines)
        matrix (tilt input :north)]
    (math.wsum (weights matrix))))

(real-input (aoc.string-from "2023/14.inp"))
#+end_src

#+RESULTS:
: 113456

* DONE Day 15.1
The  newly-focused parabolic  reflector  dish is  sending  all of  the
collected light to a  point on the side of yet  another mountain - the
largest mountain  on Lava  Island. As you  approach the  mountain, you
find that the light is being collected by the wall of a large facility
embedded in the mountainside.

You  find  a door  under  a  large  sign  that says  "Lava  Production
Facility" and  next to  a smaller  sign that  says "Danger  - Personal
Protective Equipment required beyond this point".

As you step inside, you are immediately greeted by a somewhat panicked
reindeer wearing  goggles and a  loose-fitting hard hat.  The reindeer
leads you to a  shelf of goggles and hard hats  (you quickly find some
that fit) and then further into the facility. At one point, you pass a
button  with a  faint snout  mark and  the label  "PUSH FOR  HELP". No
wonder you were loaded into that trebuchet so quickly!

You  pass through  a  final set  of doors  surrounded  with even  more
warning signs and into what must be  the room that collects all of the
light  from outside.  As you  admire  the large  assortment of  lenses
available to further  focus the light, the reindeer brings  you a book
titled "Initialization Manual".

"Hello!",  the  book  cheerfully  begins, apparently  unaware  of  the
concerned reindeer  reading over  your shoulder. "This  procedure will
let  you bring  the  Lava  Production Facility  online  - all  without
burning or melting anything unintended!"

"Before you begin, please be prepared  to use the Holiday ASCII String
Helper algorithm (appendix 1A)." You turn to appendix 1A. The reindeer
leans closer with interest.

The HASH algorithm  is a way to  turn any string of  characters into a
single number in  the range 0 to  255. To run the HASH  algorithm on a
string, start with  a current value of 0. Then,  for each character in
the string starting from the beginning:
- Determine the ASCII code for the current character of the string.
- Increase the current value by the ASCII code you just determined.
- Set the current value to itself multiplied by 17.
- Set the current value to the remainder of dividing itself by 256.

After following these steps for each character in the string in order,
the current value is the output of the HASH algorithm.

So, to find the result of running the HASH algorithm on the string HASH:
- The current value starts at 0.
- The first character is H; its ASCII code is 72.
- The current value increases to 72.
- The current value is multiplied by 17 to become 1224.
- The current value becomes 200 (the remainder of 1224 divided by 256).
- The next character is A; its ASCII code is 65.
- The current value increases to 265.
- The current value is multiplied by 17 to become 4505.
- The current value becomes 153 (the remainder of 4505 divided by 256).
- The next character is S; its ASCII code is 83.
- The current value increases to 236.
- The current value is multiplied by 17 to become 4012.
- The current value becomes 172 (the remainder of 4012 divided by 256).
- The next character is H; its ASCII code is 72.
- The current value increases to 244.
- The current value is multiplied by 17 to become 4148.
- The current value becomes 52 (the remainder of 4148 divided by 256).

So, the result of running the HASH algorithm on the string HASH is 52.

The initialization  sequence (your puzzle input)  is a comma-separated
list of  steps to start  the Lava Production Facility.  Ignore newline
characters when  parsing the  initialization sequence. To  verify that
your HASH algorithm is working, the  book offers the sum of the result
of  running the  HASH algorithm  on  each step  in the  initialization
sequence.

For example:
#+begin_example
rn=1,cm-,qp=3,cm=2,qp-,pc=4,ot=9,ab=5,pc-,pc=6,ot=7
#+end_example

This initialization sequence specifies 11 individual steps; the result
of running the HASH algorithm on each of the steps is as follows:

- rn=1 becomes 30.
- cm- becomes 253.
- qp=3 becomes 97.
- cm=2 becomes 47.
- qp- becomes 14.
- pc=4 becomes 180.
- ot=9 becomes 9.
- ab=5 becomes 197.
- pc- becomes 48.
- pc=6 becomes 214.
- ot=7 becomes 231.

In this example, the sum of  these results is 1320. Unfortunately, the
reindeer  has stolen  the  page containing  the expected  verification
number and is currently running around the facility with it excitedly.

Run  the   HASH  algorithm   on  each   step  in   the  initialization
sequence. What is the sum of the results? (The initialization sequence
is one long line; be careful when copy-pasting it.)

#+begin_src fennel :session day15
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn hash [s]
  (var result 0)
  (for [i 1 (length s) 1]
    (set result (% (* 17 (+ result (string.byte s i i))) 256)))
  result)

(fn test-input [input]
  (assert (= 1320 (aoc.table-sum (lume.map (aoc.string-split input ",") #(hash $))))))

(test-input "rn=1,cm-,qp=3,cm=2,qp-,pc=4,ot=9,ab=5,pc-,pc=6,ot=7")

(fn real-input [input]
  (aoc.table-sum (lume.map (aoc.string-split input ",") #(hash $))))

(real-input (. (aoc.string-from "2023/15.inp") 1))
#+end_src

#+RESULTS:
: 514281

