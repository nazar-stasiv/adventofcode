#+TITLE: 2022 challenge
#+AUTHOR: Advent of code
#+EMAIL: nazar@autistici.org
#+LANGUAGE: en
#+OPTIONS: title:t author:t email:nil toc:nil num:nil timestamp:nil

* DONE Day 1.1
Santa's reindeer typically eat regular  reindeer food, but they need a
lot  of magical  energy to  deliver presents  on Christmas.  For that,
their favorite snack  is a special type of star  fruit that only grows
deep  in the  jungle.  The  Elves have  brought  you  on their  annual
expedition to the grove where the fruit grows.

To supply  enough magical energy,  the expedition needs to  retrieve a
minimum of fifty stars by December 25th. Although the Elves assure you
that the grove has  plenty of fruit, you decide to  grab any fruit you
see along the way, just in case.

Collect stars by  solving puzzles. Two puzzles will  be made available
on each day in the Advent calendar; the second puzzle is unlocked when
you complete the first. Each puzzle grants one star. Good luck!

The jungle must be too overgrown and difficult to navigate in vehicles
or access  from the air;  the Elves' expedition traditionally  goes on
foot. As your boats approach land, the Elves begin taking inventory of
their supplies. One  important consideration is food  - in particular,
the number of Calories each Elf is carrying (your puzzle input).

The Elves take turns writing down  the number of Calories contained by
the various  meals, snacks,  rations, etc.  that they've  brought with
them, one item  per line. Each Elf separates their  own inventory from
the previous Elf's inventory (if any) by a blank line.

For example, suppose the Elves finish writing their items' Calories
and end up with the following list:
#+begin_example
1000
2000
3000

4000

5000
6000

7000
8000
9000

10000
#+end_example

This list represents the Calories of the food carried by five Elves:

- The first Elf is carrying food with 1000, 2000, and 3000 Calories, a
  total of 6000 Calories.
- The second Elf is carrying one food item with 4000 Calories.
- The third Elf is carrying food with 5000 and 6000 Calories, a total
  of 11000 Calories.
- The fourth Elf is carrying food with 7000, 8000, and 9000 Calories,
  a total of 24000 Calories.
- The fifth Elf is carrying one food item with 10000 Calories.

In case the Elves get hungry and  need extra snacks, they need to know
which Elf  to ask:  they'd like  to know how  many Calories  are being
carried by the  Elf carrying the most Calories. In  the example above,
this is 24000 (carried by the fourth Elf).

Find the  Elf carrying the most  Calories. How many total  Calories is
that Elf carrying?

#+begin_src fennel :session day01
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn read-input [lines]
  (let [res [[]]]
    (each [_ line (ipairs lines)]
      (let [num (tonumber line)]
        (if num
            (table.insert (. res (length res)) num)
            (table.insert res []))))
    res))

(fn solve [input]
  (let [xs (read-input input)]
    (math.max
     (table.unpack
      (lume.map xs aoc.table-sum)))))

(local input
       ["1000" "2000" "3000" ""
        "4000" ""
        "5000" "6000" ""
        "7000" "8000" "9000" ""
        "10000"])

(fn test-input [inp]
  (assert (= 24000 (solve inp))))

(test-input input)

(solve (aoc.string-from "2022/01.inp"))
#+end_src

#+RESULTS:
: 69310

* DONE Day 1.2
By the time  you calculate the answer to the  Elves' question, they've
already realized that the Elf carrying the most Calories of food might
eventually run out of snacks.

To avoid this unacceptable situation,  the Elves would instead like to
know the  total Calories carried by  the top three Elves  carrying the
most  Calories. That  way, even  if  one of  those Elves  runs out  of
snacks, they still have two backups.

In the  example above, the  top three Elves  are the fourth  Elf (with
24000 Calories),  then the third  Elf (with 11000 Calories),  then the
fifth Elf  (with 10000 Calories). The  sum of the Calories  carried by
these three elves is 45000.

Find the top three Elves carrying the most Calories. How many Calories
are those Elves carrying in total?

#+begin_src fennel :session day01
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve2 [in]
  (let [xs (read-input in)
        res (lume.map xs aoc.table-sum)]
    (table.sort res #(> $1 $2))
    (aoc.table-sum (aoc.take res 3))))

(fn test-input2 [inp]
  (assert (= 45000 (solve2 inp))))

(test-input2 input)

(solve2 (aoc.string-from "2022/01.inp"))
#+end_src

#+RESULTS:
: 206104


* DONE Day 2.1
The Elves begin to set up camp on the beach. To decide whose tent gets
to  be closest  to  the snack  storage, a  giant  Rock Paper  Scissors
tournament is already in progress.

Rock Paper Scissors is a game  between two players. Each game contains
many rounds; in each round, the players each simultaneously choose one
of Rock,  Paper, or Scissors  using a hand  shape. Then, a  winner for
that round is selected: Rock defeats Scissors, Scissors defeats Paper,
and Paper  defeats Rock. If  both players  choose the same  shape, the
round instead ends in a draw.

Appreciative of  your help yesterday,  one Elf gives you  an encrypted
strategy guide (your puzzle input) that  they say will be sure to help
you win. "The first  column is what your opponent is  going to play: A
for  Rock, B  for  Paper, and  C for  Scissors.  The second  column--"
Suddenly, the Elf is called away to help with someone's tent.

The  second column,  you  reason,  must be  what  you  should play  in
response: X for  Rock, Y for Paper, and Z  for Scissors. Winning every
time would  be suspicious, so  the responses must have  been carefully
chosen.

The winner  of the  whole tournament  is the  player with  the highest
score. Your total score is the sum  of your scores for each round. The
score for a  single round is the  score for the shape  you selected (1
for Rock,  2 for  Paper, and 3  for Scissors) plus  the score  for the
outcome of the round (0 if you lost,  3 if the round was a draw, and 6
if you won).

Since you can't be sure if the Elf is trying to help you or trick you,
you should calculate the score you would get if you were to follow the
strategy guide.

For example, suppose you were given the following strategy guide:
#+begin_example
A Y
B X
C Z
#+end_example

This strategy guide predicts and recommends the following:
- In the  first round,  your opponent  will choose  Rock (A),  and you
  should choose Paper (Y). This ends in  a win for you with a score of
  8 (2 because you chose Paper + 6 because you won).
- In the  second round, your opponent  will choose Paper (B),  and you
  should choose Rock (X). This ends in  a loss for you with a score of
  1 (1 + 0).
- The  third round  is a  draw  with both  players choosing  Scissors,
  giving you a score of 3 + 3 = 6.
  
In this example,  if you were to follow the  strategy guide, you would
get a total score of 15 (8 + 1 + 6).

What would your total score be if everything goes exactly according to
your strategy guide?

#+begin_src fennel :session day02
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn read-input [lines]
  (let [res []]
    (each [_ line (ipairs lines)]
      (table.insert res (aoc.string-split line " ")))
    res))

(fn score [[i j]]
  (let [rock 1
        paper 2
        scissors 3]
    (case [i j]
      [:A :X] (+ rock 3)
      [:A :Y] (+ paper 6)
      [:A :Z] (+ scissors 0)
      [:B :X] (+ rock 0)
      [:B :Y] (+ paper 3)
      [:B :Z] (+ scissors 6)
      [:C :X] (+ rock 6)
      [:C :Y] (+ paper 0)
      [:C :Z] (+ scissors 3))))

(local input ["A Y" "B X" "C Z"])

(fn test-input [in]
  (assert (= 15 (aoc.table-sum (lume.map (read-input in) #(score $))))))

(test-input input)

(fn real-input [in]
  (aoc.table-sum (lume.map (read-input in) #(score $))))

(real-input (aoc.string-from "2022/02.inp"))
#+end_src

#+RESULTS:
: 15572

* DONE Day 2.2
The  Elf finishes  helping  with  the tent  and  sneaks  back over  to
you. "Anyway,  the second column  says how the  round needs to  end: X
means you need to  lose, Y means you need to end the  round in a draw,
and Z means you need to win. Good luck!"

The total score is still calculated in  the same way, but now you need
to figure out what shape to choose so the round ends as indicated. The
example above now goes like this:
- In the first round, your opponent will choose Rock (A), and you need
  the round to end in a draw  (Y), so you also choose Rock. This gives
  you a score of 1 + 3 = 4.
- In the  second round, your opponent  will choose Paper (B),  and you
  choose Rock so you lose (X) with a score of 1 + 0 = 1.
- In the  third round, you  will defeat your opponent's  Scissors with
  Rock for a score of 1 + 6 = 7.
  
Now that  you're correctly  decrypting the  ultra top  secret strategy
guide, you would get a total score of 12.

Following the  Elf's instructions  for the  second column,  what would
your  total score  be if  everything  goes exactly  according to  your
strategy guide?

#+begin_src fennel :session day02
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn score2 [[i j]]
  (let [rock 1 paper 2 scissors 3
        win 6 draw 3 loose 0]
    (case [i j]
      [:A :X] (+ scissors loose)
      [:A :Y] (+ rock draw)
      [:A :Z] (+ paper win)
      [:B :X] (+ rock loose)
      [:B :Y] (+ paper draw)
      [:B :Z] (+ scissors win)
      [:C :X] (+ paper loose)
      [:C :Y] (+ scissors draw)
      [:C :Z] (+ rock win))))

(local input2 ["A Y" "B X" "C Z"])

(fn test-input2 [in]
  (assert (= 12 (aoc.table-sum (lume.map (read-input in) #(score2 $))))))

(test-input2 input2)

(fn real-input2 [in]
  (aoc.table-sum (lume.map (read-input in) #(score2 $))))

(real-input2 (aoc.string-from "2022/02.inp"))

#+end_src

#+RESULTS:
: 16098

* DONE Day 3.1
One Elf  has the important  job of loading  all of the  rucksacks with
supplies for the jungle journey.  Unfortunately, that Elf didn't quite
follow the  packing instructions, and  so a few  items now need  to be
rearranged.

Each rucksack  has two large compartments.  All items of a  given type
are meant to go into exactly one of the two compartments. The Elf that
did the packing  failed to follow this rule for  exactly one item type
per rucksack.

The Elves  have made  a list  of all  of the  items currently  in each
rucksack  (your puzzle  input), but  they need  your help  finding the
errors.  Every  item type  is  identified  by  a single  lowercase  or
uppercase letter (that is, a and A refer to different types of items).

The list of  items for each rucksack  is given as characters  all on a
single line. A  given rucksack always has the same  number of items in
each of  its two  compartments, so  the first  half of  the characters
represent items in the first compartment, while the second half of the
characters represent items in the second compartment.

For example, suppose you have the following list of contents from six
rucksacks:
#+begin_example
vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
#+end_example

- The  first  rucksack  contains the  items  vJrwpWtwJgWrhcsFMMfFFhFp,
  which means  its first compartment contains  the items vJrwpWtwJgWr,
  while the  second compartment  contains the items  hcsFMMfFFhFp. The
  only item type that appears in both compartments is lowercase p.
- The  second  rucksack's  compartments contain  jqHRNqRjqzjGDLGL  and
  rsFMfFZSrLrFZsSL.  The   only  item   type  that  appears   in  both
  compartments is uppercase L.
- The third  rucksack's compartments contain PmmdzqPrV  and vPwwTWBwg;
  the only common item type is uppercase P.
- The fourth rucksack's compartments only share item type v.
- The fifth rucksack's compartments only share item type t.
- The sixth rucksack's compartments only share item type s.

To  help  prioritize  item  rearrangement,  every  item  type  can  be
converted to a priority:
- Lowercase item types a through z have priorities 1 through 26.
- Uppercase item types A through Z have priorities 27 through 52.

In the  above example, the priority  of the item type  that appears in
both compartments of each rucksack is 16  (p), 38 (L), 42 (P), 22 (v),
20 (t), and 19 (s); the sum of these is 157.

Find  the  item  type  that  appears  in  both  compartments  of  each
rucksack. What is the sum of the priorities of those item types?

#+begin_src fennel :session day03
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn items-to-codes [line]
  (let [score {:a 1 :b 2 :c 3 :d 4 :e 5 :f 6 :g 7 :h 8 :i 9
               :j 10 :k 11 :l 12 :m 13 :n 14 :o 15 :p 16 :q 17
               :r 18 :s 19 :t 20 :u 21 :v 22 :w 23 :x 24 :y 25
               :z 26 :A 27 :B 28 :C 29 :D 30 :E 31 :F 32 :G 33
               :H 34 :I 35 :J 36 :K 37 :L 38 :M 39 :N 40 :O 41
               :P 42 :Q 43 :R 44 :S 45 :T 46 :U 47 :V 48 :W 49
               :X 50 :Y 51 :Z 52}]
    (lume.map (aoc.string-toarray line) #(. score $))))

(fn solve-p1 [line]
  (let [in2 (items-to-codes line)
        len (length in2)
        in3 (aoc.table-range in2 1 (// len 2))
        in4 (aoc.table-range in2 (+ 1 (// len 2)) len)]
    (lume.unique (lume.filter in3 (fn [e] (aoc.table-contains? in4 e))))))

(local input
       ["vJrwpWtwJgWrhcsFMMfFFhFp"
        "jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL"
        "PmmdzqPrVvPwwTWBwg"
        "wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn"
        "ttgJtRGJQctTZtZT"
        "CrZsJsPPZsGzwwsLwLmpwMDw"])

(fn test-input [in]
  (assert (= 157 (aoc.table-sum (lume.map in #(solve-p1 $))))))

(test-input input)

(fn real-input [in]
  (aoc.table-sum (lume.map in #(solve-p1 $))))

(real-input (aoc.string-from "2022/03.inp"))
#+end_src

#+RESULTS:
: 8085

* DONE Day 3.2
As you finish  identifying the misplaced items, the Elves  come to you
with another issue.

For safety,  the Elves  are divided  into groups  of three.  Every Elf
carries a  badge that identifies  their group. For  efficiency, within
each group of three Elves, the badge  is the only item type carried by
all three Elves. That is, if a  group's badge is item type B, then all
three Elves will have item type  B somewhere in their rucksack, and at
most two of the Elves will be carrying any other item type.

The  problem  is  that  someone  forgot to  put  this  year's  updated
authenticity  sticker on  the badges.  All of  the badges  need to  be
pulled out  of the rucksacks so  the new authenticity stickers  can be
attached.

Additionally, nobody  wrote down which  item type corresponds  to each
group's badges. The only way to tell  which item type is the right one
is by finding the one item type that is common between all three Elves
in each group.

Every set of  three lines in your list corresponds  to a single group,
but each group can have a different  badge item type. So, in the above
example, the first group's rucksacks are the first three lines:
#+begin_example
vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
#+end_example

And the second group's rucksacks are the next three lines:
#+begin_example
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
#+end_example

In  the first  group, the  only item  type that  appears in  all three
rucksacks is  lowercase r; this  must be  their badges. In  the second
group, their badge item type must be Z.

Priorities for these items must still be found to organize the sticker
attachment efforts: here,  they are 18 (r) for the  first group and 52
(Z) for the second group. The sum of these is 70.

Find the  item type that corresponds  to the badges of  each three-Elf
group. What is the sum of the priorities of those item types?

#+begin_src fennel :session day03
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve-p2 [l1 l2 l3]
  (let [c1 (items-to-codes l1)
        c2 (items-to-codes l2)
        c3 (items-to-codes l3)
        common (lume.filter c2 (fn [e] (aoc.table-contains? c3 e)))]
    (lume.unique (lume.filter c1 (fn [e] (aoc.table-contains? common e))))))

(fn test-input-p2 [in]
  (assert (= 70 (aoc.table-sum
                 (lume.map (aoc.table-group-by input 3)
                           #(solve-p2 (table.unpack $)))))))

(test-input-p2 input)

(fn real-input-p2 [in]
  (aoc.table-sum
   (lume.map (aoc.table-group-by in 3)
             #(solve-p2 (table.unpack $)))))

(real-input-p2 (aoc.string-from "2022/03.inp"))
#+end_src

#+RESULTS:
: 2515

* DONE Day 4.1
Space needs  to be cleared  before the  last supplies can  be unloaded
from the  ships, and so  several Elves have  been assigned the  job of
cleaning  up sections  of the  camp.  Every  section has  a unique  ID
number, and each Elf is assigned a range of section IDs.

However, as some  of the Elves compare their  section assignments with
each other, they've  noticed that many of the  assignments overlap. To
try to quickly  find overlaps and reduce duplicated  effort, the Elves
pair up and make  a big list of the section  assignments for each pair
(your puzzle input).

For example, consider the following list of section assignment pairs:
#+begin_example
2-4,6-8
2-3,4-5
5-7,7-9
2-8,3-7
6-6,4-6
2-6,4-8
#+end_example

For the first few pairs, this list means:
- Within the first pair of Elves,  the first Elf was assigned sections
  2-4  (sections 2,  3,  and 4),  while the  second  Elf was  assigned
  sections 6-8 (sections 6, 7, 8).
- The Elves in the second pair were each assigned two sections.
- The Elves in  the third pair were each assigned  three sections: one
  got sections 5, 6, and 7, while the other also got 7, plus 8 and 9.
  
This example list  uses single-digit section IDs to make  it easier to
draw; your actual  list might contain larger  numbers. Visually, these
pairs of section assignments look like this:
#+begin_example
.234.....  2-4
.....678.  6-8

.23......  2-3
...45....  4-5

....567..  5-7
......789  7-9

.2345678.  2-8
..34567..  3-7

.....6...  6-6
...456...  4-6

.23456...  2-6
...45678.  4-8
#+end_example

Some of  the pairs have  noticed that  one of their  assignments fully
contains the  other. For example, 2-8  fully contains 3-7, and  6-6 is
fully contained by  4-6. In pairs where one  assignment fully contains
the other, one Elf in the  pair would be exclusively cleaning sections
their partner will already be cleaning, so these seem like the most in
need of reconsideration. In this example, there are 2 such pairs.

In how many assignment pairs does one range fully contain the other?

#+begin_src fennel :session day04
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve [line]
  (let [[elf1 elf2] (aoc.string-split line ",")
        [f1 t1] (aoc.string-split elf1 "-")
        [f2 t2] (aoc.string-split elf2 "-")]
    (or (and (<= (aoc.int f1) (aoc.int f2)) (>= (aoc.int t1) (aoc.int t2)))
        (and (>= (aoc.int f1) (aoc.int f2)) (<= (aoc.int t1) (aoc.int t2))))))

(local input
       ["2-4,6-8"
        "2-3,4-5"
        "5-7,7-9"
        "2-8,3-7"
        "6-6,4-6"
        "2-6,4-8"])

(fn test-input [in]
  (assert
   (= 2 (length
         (lume.filter
          (lume.map in #(solve $))
          #(if $ true false))))))

(test-input input)

(fn real-input [in]
  (length
   (lume.filter
    (lume.map in #(solve $))
    #(if $ true false))))

(real-input (aoc.string-from "2022/04.inp"))
#+end_src

#+RESULTS:
: 536

* DONE Day 4.2
It  seems  like  there  is  still   quite  a  bit  of  duplicate  work
planned. Instead,  the Elves would  like to  know the number  of pairs
that overlap at all.

In the above example, the first  two pairs (2-4,6-8 and 2-3,4-5) don't
overlap, while  the remaining  four pairs (5-7,7-9,  2-8,3-7, 6-6,4-6,
and 2-6,4-8) do overlap:
- 5-7,7-9 overlaps in a single section, 7.
- 2-8,3-7 overlaps all of the sections 3 through 7.
- 6-6,4-6 overlaps in a single section, 6.
- 2-6,4-8 overlaps in sections 4, 5, and 6.

So,  in  this example,  the  number  of overlapping  assignment  pairs
is 4. In how many assignment pairs do the ranges overlap?

#+begin_src fennel :session day04
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve2 [line]
  (let [[elf1 elf2] (aoc.string-split line ",")
        [f1 t1] (aoc.string-split elf1 "-")
        [f2 t2] (aoc.string-split elf2 "-")]
    (or (and (<= (aoc.int f1) (aoc.int f2)) (>= (aoc.int t1) (aoc.int f2)))
        (and (<= (aoc.int f1) (aoc.int t2)) (>= (aoc.int t1) (aoc.int t2)))
        (and (<= (aoc.int f2) (aoc.int f1)) (>= (aoc.int t2) (aoc.int f1)))
        (and (<= (aoc.int f2) (aoc.int t1)) (>= (aoc.int t2) (aoc.int t1))))))

(fn test-input-2 [in]
  (assert
   (= 4 (length
         (lume.filter
          (lume.map in #(solve2 $))
          #(if $ true false))))))

(test-input-2 input)

(fn real-input-2 [in]
  (length
   (lume.filter
    (lume.map in #(solve2 $))
    #(if $ true false))))

(real-input-2 (aoc.string-from "2022/04.inp"))
#+end_src

#+RESULTS:
: 845

* DONE Day 5.1
The expedition  can depart  as soon  as the  final supplies  have been
unloaded  from the  ships. Supplies  are  stored in  stacks of  marked
crates, but  because the needed  supplies are buried under  many other
crates, the crates need to be rearranged.

The ship  has a  giant cargo  crane capable  of moving  crates between
stacks. To  ensure none of  the crates get  crushed or fall  over, the
crane operator  will rearrange them  in a series  of carefully-planned
steps. After the crates are rearranged,  the desired crates will be at
the top of each stack.

The  Elves don't  want to  interrupt  the crane  operator during  this
delicate procedure, but they forgot to ask her which crate will end up
where, and they want to be ready to unload them as soon as possible so
they can embark.

They do, however, have a drawing of the starting stacks of crates and
the rearrangement procedure (your puzzle input). For example:
#+begin_example
    [D]    
[N] [C]    
[Z] [M] [P]
 1   2   3 

move 1 from 2 to 1
move 3 from 1 to 3
move 2 from 2 to 1
move 1 from 1 to 2
#+end_example

In this  example, there are three  stacks of crates. Stack  1 contains
two crates: crate Z  is on the bottom, and crate N is  on top. Stack 2
contains three crates;  from bottom to top, they are  crates M, C, and
D. Finally, stack 3 contains a single crate, P.

Then,  the rearrangement  procedure  is  given. In  each  step of  the
procedure, a quantity of crates is moved from one stack to a different
stack. In  the first  step of the  above rearrangement  procedure, one
crate  is  moved   from  stack  2  to  stack  1,   resulting  in  this
configuration:
#+begin_example
[D]        
[N] [C]    
[Z] [M] [P]
 1   2   3 
#+end_example

In  the  second  step,  three  crates   are  moved  from  stack  1  to
stack 3.  Crates are moved  one at  a time, so  the first crate  to be
moved (D) ends up below the second and third crates:

#+begin_example
        [Z]
        [N]
    [C] [D]
    [M] [P]
 1   2   3
#+end_example

Then, both crates are moved from stack 2 to stack 1. Again, because
crates are moved one at a time, crate C ends up below crate M:
#+begin_example
        [Z]
        [N]
[M]     [D]
[C]     [P]
 1   2   3
#+end_example

Finally, one crate is moved from stack 1 to stack 2:
#+begin_example
        [Z]
        [N]
        [D]
[C] [M] [P]
 1   2   3
#+end_example

The Elves  just need to know  which crate will  end up on top  of each
stack; in this example, the top crates are C in stack 1, M in stack 2,
and Z in  stack 3, so you  should combine these together  and give the
Elves the message CMZ.

After the rearrangement procedure completes, what crate ends up on top
of each stack?

#+begin_src fennel :session day05
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(macro times [t body1 & rest-body]
  `(fcollect [i# 1 ,t 1]
     (do ,body1 ,(unpack rest-body))))

(fn test-input []
  (let [crates [["N" "Z"] ["D" "C" "M"] ["P"]]
        moves [[1 2 1] [3 1 3] [2 2 1] [1 1 2]]]
    (each [_ [n f t] (ipairs moves)]
      (times n (aoc.table-move 1 (. crates f) (. crates t))))
    (assert (= "CMZ"
               (aoc.table-tostring (. (aoc.table-transpose crates) 1))))))

(test-input)

(fn scan-crates [lines]
  (let [in (lume.map (aoc.table-range lines 1 8) #(aoc.string-toarray $))
        loc [2 6 10 14 18 22 26 30 34]
        res []]
    (each [i v (ipairs loc)]
      (table.insert res i
                    (lume.filter
                     [(. (. in 1) v) (. (. in 2) v) (. (. in 3) v)
                      (. (. in 4) v) (. (. in 5) v) (. (. in 6) v)
                      (. (. in 7) v) (. (. in 8) v)]
                     #(not= $ " "))))
    res))

(fn scan-moves [lines]
  (lume.map (aoc.table-range lines 11 (length lines))
            #(aoc.string-tonumarray $)))

(fn real-input [lines]
  (let [crates (scan-crates lines)
        moves (scan-moves lines)]
    (each [_ [n f t] (ipairs moves)]
      (times n (aoc.table-move 1 (. crates f) (. crates t))))
    (aoc.table-tostring (. (aoc.table-transpose crates) 1))))

(real-input (aoc.string-from "2022/05.inp"))
#+end_src

#+RESULTS:
: GFTNRBZPF

* DONE Day 5.2
As you  watch the  crane operator expertly  rearrange the  crates, you
notice the process isn't following your prediction.

Some mud was  covering the writing on  the side of the  crane, and you
quickly  wipe it  away. The  crane isn't  a CrateMover  9000 -  it's a
CrateMover 9001.

The CrateMover 9001 is notable for many new and exciting features: air
conditioning, leather seats,  an extra cup holder, and  the ability to
pick up and move multiple crates at once.

Again  considering the  example above,  the crates  begin in  the same
configuration:
#+begin_example
    [D]    
[N] [C]    
[Z] [M] [P]
 1   2   3 
#+end_example

Moving a  single crate  from stack 2  to stack 1  behaves the  same as
before:
#+begin_example
[D]        
[N] [C]    
[Z] [M] [P]
 1   2   3 
#+end_example

However, the  action of moving  three crates from  stack 1 to  stack 3
means that those three moved crates  stay in the same order, resulting
in this new configuration:
#+begin_example
        [D]
        [N]
    [C] [Z]
    [M] [P]
 1   2   3
#+end_example

Next, as both  crates are moved from  stack 2 to stack  1, they retain
their order as well:
#+begin_example
        [D]
        [N]
[C]     [Z]
[M]     [P]
 1   2   3
#+end_example

Finally, a single  crate is still moved  from stack 1 to  stack 2, but
now it's crate C that gets moved:
#+begin_example
        [D]
        [N]
        [Z]
[M] [C] [P]
 1   2   3
#+end_example

In this example,  the CrateMover 9001 has put the  crates in a totally
different order: MCD.

Before the  rearrangement process finishes, update  your simulation so
that the Elves know where they should  stand to be ready to unload the
final  supplies. After  the  rearrangement  procedure completes,  what
crate ends up on top of each stack?

#+begin_src fennel :session day05
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn test-input-p2 []
  (let [crates [["N" "Z"] ["D" "C" "M"] ["P"]]
        moves [[1 2 1] [3 1 3] [2 2 1] [1 1 2]]]
    (each [_ [n f t] (ipairs moves)]
      (aoc.table-move 1 (. crates f) (. crates t) n))
    (assert (= "MCD"
               (aoc.table-tostring (. (aoc.table-transpose crates) 1))))))

(test-input-p2)

(fn real-input-p2 [lines]
  (let [crates (scan-crates lines)
        moves (scan-moves lines)]
    (each [_ [n f t] (ipairs moves)]
      (aoc.table-move 1 (. crates f) (. crates t) n))
    (aoc.table-tostring (. (aoc.table-transpose crates) 1))))

(real-input-p2 (aoc.string-from "2022/05.inp"))

#+end_src

#+RESULTS:
: VRQWPDSGP
