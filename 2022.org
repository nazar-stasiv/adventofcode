#+TITLE: 2022 challenge
#+AUTHOR: Advent of code
#+EMAIL: nazar@autistici.org
#+LANGUAGE: en
#+OPTIONS: title:t author:t email:nil toc:nil num:nil timestamp:nil

* DONE Day 1.1
Santa's reindeer typically eat regular  reindeer food, but they need a
lot  of magical  energy to  deliver presents  on Christmas.  For that,
their favorite snack  is a special type of star  fruit that only grows
deep  in the  jungle.  The  Elves have  brought  you  on their  annual
expedition to the grove where the fruit grows.

To supply  enough magical energy,  the expedition needs to  retrieve a
minimum of fifty stars by December 25th. Although the Elves assure you
that the grove has  plenty of fruit, you decide to  grab any fruit you
see along the way, just in case.

Collect stars by  solving puzzles. Two puzzles will  be made available
on each day in the Advent calendar; the second puzzle is unlocked when
you complete the first. Each puzzle grants one star. Good luck!

The jungle must be too overgrown and difficult to navigate in vehicles
or access  from the air;  the Elves' expedition traditionally  goes on
foot. As your boats approach land, the Elves begin taking inventory of
their supplies. One  important consideration is food  - in particular,
the number of Calories each Elf is carrying (your puzzle input).

The Elves take turns writing down  the number of Calories contained by
the various  meals, snacks,  rations, etc.  that they've  brought with
them, one item  per line. Each Elf separates their  own inventory from
the previous Elf's inventory (if any) by a blank line.

For example, suppose the Elves finish writing their items' Calories
and end up with the following list:
#+begin_example
1000
2000
3000

4000

5000
6000

7000
8000
9000

10000
#+end_example

This list represents the Calories of the food carried by five Elves:

- The first Elf is carrying food with 1000, 2000, and 3000 Calories, a
  total of 6000 Calories.
- The second Elf is carrying one food item with 4000 Calories.
- The third Elf is carrying food with 5000 and 6000 Calories, a total
  of 11000 Calories.
- The fourth Elf is carrying food with 7000, 8000, and 9000 Calories,
  a total of 24000 Calories.
- The fifth Elf is carrying one food item with 10000 Calories.

In case the Elves get hungry and  need extra snacks, they need to know
which Elf  to ask:  they'd like  to know how  many Calories  are being
carried by the  Elf carrying the most Calories. In  the example above,
this is 24000 (carried by the fourth Elf).

Find the  Elf carrying the most  Calories. How many total  Calories is
that Elf carrying?

#+begin_src fennel :session day01
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn read-input [lines]
  (let [res [[]]]
    (each [_ line (ipairs lines)]
      (let [num (tonumber line)]
        (if num
            (table.insert (. res (length res)) num)
            (table.insert res []))))
    res))

(fn solve [input]
  (let [xs (read-input input)]
    (aoc.table-max
     (lume.map xs aoc.table-sum))))

(local input
       ["1000" "2000" "3000" ""
        "4000" ""
        "5000" "6000" ""
        "7000" "8000" "9000" ""
        "10000"])

(fn test-input [inp]
  (assert (= 24000 (solve inp))))

(test-input input)

(solve (aoc.string-from "2022/01.inp"))
#+end_src

#+RESULTS:
: 69310

* DONE Day 1.2
By the time  you calculate the answer to the  Elves' question, they've
already realized that the Elf carrying the most Calories of food might
eventually run out of snacks.

To avoid this unacceptable situation,  the Elves would instead like to
know the  total Calories carried by  the top three Elves  carrying the
most  Calories. That  way, even  if  one of  those Elves  runs out  of
snacks, they still have two backups.

In the  example above, the  top three Elves  are the fourth  Elf (with
24000 Calories),  then the third  Elf (with 11000 Calories),  then the
fifth Elf  (with 10000 Calories). The  sum of the Calories  carried by
these three elves is 45000.

Find the top three Elves carrying the most Calories. How many Calories
are those Elves carrying in total?

#+begin_src fennel :session day01
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve2 [in]
  (let [xs (read-input in)
        res (lume.map xs aoc.table-sum)]
    (table.sort res #(> $1 $2))
    (aoc.table-sum (aoc.take res 3))))

(fn test-input2 [inp]
  (assert (= 45000 (solve2 inp))))

(test-input2 input)

(solve2 (aoc.string-from "2022/01.inp"))
#+end_src

#+RESULTS:
: 206104


* DONE Day 2.1
The Elves begin to set up camp on the beach. To decide whose tent gets
to  be closest  to  the snack  storage, a  giant  Rock Paper  Scissors
tournament is already in progress.

Rock Paper Scissors is a game  between two players. Each game contains
many rounds; in each round, the players each simultaneously choose one
of Rock,  Paper, or Scissors  using a hand  shape. Then, a  winner for
that round is selected: Rock defeats Scissors, Scissors defeats Paper,
and Paper  defeats Rock. If  both players  choose the same  shape, the
round instead ends in a draw.

Appreciative of  your help yesterday,  one Elf gives you  an encrypted
strategy guide (your puzzle input) that  they say will be sure to help
you win. "The first  column is what your opponent is  going to play: A
for  Rock, B  for  Paper, and  C for  Scissors.  The second  column--"
Suddenly, the Elf is called away to help with someone's tent.

The  second column,  you  reason,  must be  what  you  should play  in
response: X for  Rock, Y for Paper, and Z  for Scissors. Winning every
time would  be suspicious, so  the responses must have  been carefully
chosen.

The winner  of the  whole tournament  is the  player with  the highest
score. Your total score is the sum  of your scores for each round. The
score for a  single round is the  score for the shape  you selected (1
for Rock,  2 for  Paper, and 3  for Scissors) plus  the score  for the
outcome of the round (0 if you lost,  3 if the round was a draw, and 6
if you won).

Since you can't be sure if the Elf is trying to help you or trick you,
you should calculate the score you would get if you were to follow the
strategy guide.

For example, suppose you were given the following strategy guide:
#+begin_example
A Y
B X
C Z
#+end_example

This strategy guide predicts and recommends the following:
- In the  first round,  your opponent  will choose  Rock (A),  and you
  should choose Paper (Y). This ends in  a win for you with a score of
  8 (2 because you chose Paper + 6 because you won).
- In the  second round, your opponent  will choose Paper (B),  and you
  should choose Rock (X). This ends in  a loss for you with a score of
  1 (1 + 0).
- The  third round  is a  draw  with both  players choosing  Scissors,
  giving you a score of 3 + 3 = 6.
  
In this example,  if you were to follow the  strategy guide, you would
get a total score of 15 (8 + 1 + 6).

What would your total score be if everything goes exactly according to
your strategy guide?

#+begin_src fennel :session day02
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn read-input [lines]
  (let [res []]
    (each [_ line (ipairs lines)]
      (table.insert res (aoc.string-split line " ")))
    res))

(fn score [[i j]]
  (let [rock 1
        paper 2
        scissors 3]
    (case [i j]
      [:A :X] (+ rock 3)
      [:A :Y] (+ paper 6)
      [:A :Z] (+ scissors 0)
      [:B :X] (+ rock 0)
      [:B :Y] (+ paper 3)
      [:B :Z] (+ scissors 6)
      [:C :X] (+ rock 6)
      [:C :Y] (+ paper 0)
      [:C :Z] (+ scissors 3))))

(local input ["A Y" "B X" "C Z"])

(fn test-input [in]
  (assert (= 15 (aoc.table-sum (lume.map (read-input in) #(score $))))))

(test-input input)

(fn real-input [in]
  (aoc.table-sum (lume.map (read-input in) #(score $))))

(real-input (aoc.string-from "2022/02.inp"))
#+end_src

#+RESULTS:
: 15572

* DONE Day 2.2
The  Elf finishes  helping  with  the tent  and  sneaks  back over  to
you. "Anyway,  the second column  says how the  round needs to  end: X
means you need to  lose, Y means you need to end the  round in a draw,
and Z means you need to win. Good luck!"

The total score is still calculated in  the same way, but now you need
to figure out what shape to choose so the round ends as indicated. The
example above now goes like this:
- In the first round, your opponent will choose Rock (A), and you need
  the round to end in a draw  (Y), so you also choose Rock. This gives
  you a score of 1 + 3 = 4.
- In the  second round, your opponent  will choose Paper (B),  and you
  choose Rock so you lose (X) with a score of 1 + 0 = 1.
- In the  third round, you  will defeat your opponent's  Scissors with
  Rock for a score of 1 + 6 = 7.
  
Now that  you're correctly  decrypting the  ultra top  secret strategy
guide, you would get a total score of 12.

Following the  Elf's instructions  for the  second column,  what would
your  total score  be if  everything  goes exactly  according to  your
strategy guide?

#+begin_src fennel :session day02
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn score2 [[i j]]
  (let [rock 1 paper 2 scissors 3
        win 6 draw 3 loose 0]
    (case [i j]
      [:A :X] (+ scissors loose)
      [:A :Y] (+ rock draw)
      [:A :Z] (+ paper win)
      [:B :X] (+ rock loose)
      [:B :Y] (+ paper draw)
      [:B :Z] (+ scissors win)
      [:C :X] (+ paper loose)
      [:C :Y] (+ scissors draw)
      [:C :Z] (+ rock win))))

(local input2 ["A Y" "B X" "C Z"])

(fn test-input2 [in]
  (assert (= 12 (aoc.table-sum (lume.map (read-input in) #(score2 $))))))

(test-input2 input2)

(fn real-input2 [in]
  (aoc.table-sum (lume.map (read-input in) #(score2 $))))

(real-input2 (aoc.string-from "2022/02.inp"))

#+end_src

#+RESULTS:
: 16098

* DONE Day 3.1
One Elf  has the important  job of loading  all of the  rucksacks with
supplies for the jungle journey.  Unfortunately, that Elf didn't quite
follow the  packing instructions, and  so a few  items now need  to be
rearranged.

Each rucksack  has two large compartments.  All items of a  given type
are meant to go into exactly one of the two compartments. The Elf that
did the packing  failed to follow this rule for  exactly one item type
per rucksack.

The Elves  have made  a list  of all  of the  items currently  in each
rucksack  (your puzzle  input), but  they need  your help  finding the
errors.  Every  item type  is  identified  by  a single  lowercase  or
uppercase letter (that is, a and A refer to different types of items).

The list of  items for each rucksack  is given as characters  all on a
single line. A  given rucksack always has the same  number of items in
each of  its two  compartments, so  the first  half of  the characters
represent items in the first compartment, while the second half of the
characters represent items in the second compartment.

For example, suppose you have the following list of contents from six
rucksacks:
#+begin_example
vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
#+end_example

- The  first  rucksack  contains the  items  vJrwpWtwJgWrhcsFMMfFFhFp,
  which means  its first compartment contains  the items vJrwpWtwJgWr,
  while the  second compartment  contains the items  hcsFMMfFFhFp. The
  only item type that appears in both compartments is lowercase p.
- The  second  rucksack's  compartments contain  jqHRNqRjqzjGDLGL  and
  rsFMfFZSrLrFZsSL.  The   only  item   type  that  appears   in  both
  compartments is uppercase L.
- The third  rucksack's compartments contain PmmdzqPrV  and vPwwTWBwg;
  the only common item type is uppercase P.
- The fourth rucksack's compartments only share item type v.
- The fifth rucksack's compartments only share item type t.
- The sixth rucksack's compartments only share item type s.

To  help  prioritize  item  rearrangement,  every  item  type  can  be
converted to a priority:
- Lowercase item types a through z have priorities 1 through 26.
- Uppercase item types A through Z have priorities 27 through 52.

In the  above example, the priority  of the item type  that appears in
both compartments of each rucksack is 16  (p), 38 (L), 42 (P), 22 (v),
20 (t), and 19 (s); the sum of these is 157.

Find  the  item  type  that  appears  in  both  compartments  of  each
rucksack. What is the sum of the priorities of those item types?

#+begin_src fennel :session day03
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn items-to-codes [line]
  (let [score {:a 1 :b 2 :c 3 :d 4 :e 5 :f 6 :g 7 :h 8 :i 9
               :j 10 :k 11 :l 12 :m 13 :n 14 :o 15 :p 16 :q 17
               :r 18 :s 19 :t 20 :u 21 :v 22 :w 23 :x 24 :y 25
               :z 26 :A 27 :B 28 :C 29 :D 30 :E 31 :F 32 :G 33
               :H 34 :I 35 :J 36 :K 37 :L 38 :M 39 :N 40 :O 41
               :P 42 :Q 43 :R 44 :S 45 :T 46 :U 47 :V 48 :W 49
               :X 50 :Y 51 :Z 52}]
    (lume.map (aoc.string-toarray line) #(. score $))))

(fn solve-p1 [line]
  (let [in2 (items-to-codes line)
        len (length in2)
        in3 (aoc.table-range in2 1 (aoc.int/ len 2))
        in4 (aoc.table-range in2 (+ 1 (aoc.int/ len 2)) len)]
    (lume.unique (lume.filter in3 (fn [e] (aoc.table-contains? in4 e))))))

(local input
       ["vJrwpWtwJgWrhcsFMMfFFhFp"
        "jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL"
        "PmmdzqPrVvPwwTWBwg"
        "wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn"
        "ttgJtRGJQctTZtZT"
        "CrZsJsPPZsGzwwsLwLmpwMDw"])

(fn test-input [in]
  (assert (= 157 (aoc.table-sum (lume.map in #(solve-p1 $))))))

(test-input input)

(fn real-input [in]
  (aoc.table-sum (lume.map in #(solve-p1 $))))

(real-input (aoc.string-from "2022/03.inp"))
#+end_src

#+RESULTS:
: 8085

* DONE Day 3.2
As you finish  identifying the misplaced items, the Elves  come to you
with another issue.

For safety,  the Elves  are divided  into groups  of three.  Every Elf
carries a  badge that identifies  their group. For  efficiency, within
each group of three Elves, the badge  is the only item type carried by
all three Elves. That is, if a  group's badge is item type B, then all
three Elves will have item type  B somewhere in their rucksack, and at
most two of the Elves will be carrying any other item type.

The  problem  is  that  someone  forgot to  put  this  year's  updated
authenticity  sticker on  the badges.  All of  the badges  need to  be
pulled out  of the rucksacks so  the new authenticity stickers  can be
attached.

Additionally, nobody  wrote down which  item type corresponds  to each
group's badges. The only way to tell  which item type is the right one
is by finding the one item type that is common between all three Elves
in each group.

Every set of  three lines in your list corresponds  to a single group,
but each group can have a different  badge item type. So, in the above
example, the first group's rucksacks are the first three lines:
#+begin_example
vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
#+end_example

And the second group's rucksacks are the next three lines:
#+begin_example
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
#+end_example

In  the first  group, the  only item  type that  appears in  all three
rucksacks is  lowercase r; this  must be  their badges. In  the second
group, their badge item type must be Z.

Priorities for these items must still be found to organize the sticker
attachment efforts: here,  they are 18 (r) for the  first group and 52
(Z) for the second group. The sum of these is 70.

Find the  item type that corresponds  to the badges of  each three-Elf
group. What is the sum of the priorities of those item types?

#+begin_src fennel :session day03
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve-p2 [l1 l2 l3]
  (let [c1 (items-to-codes l1)
        c2 (items-to-codes l2)
        c3 (items-to-codes l3)
        common (lume.filter c2 (fn [e] (aoc.table-contains? c3 e)))]
    (lume.unique (lume.filter c1 (fn [e] (aoc.table-contains? common e))))))

(fn test-input-p2 [in]
  (assert (= 70 (aoc.table-sum
                 (lume.map (aoc.table-group-by input 3)
                           #(solve-p2 (aoc.table-unpack $)))))))

(test-input-p2 input)

(fn real-input-p2 [in]
  (aoc.table-sum
   (lume.map (aoc.table-group-by in 3)
             #(solve-p2 (aoc.table-unpack $)))))

(real-input-p2 (aoc.string-from "2022/03.inp"))
#+end_src

#+RESULTS:
: 2515

* DONE Day 4.1
Space needs  to be cleared  before the  last supplies can  be unloaded
from the  ships, and so  several Elves have  been assigned the  job of
cleaning  up sections  of the  camp.  Every  section has  a unique  ID
number, and each Elf is assigned a range of section IDs.

However, as some  of the Elves compare their  section assignments with
each other, they've  noticed that many of the  assignments overlap. To
try to quickly  find overlaps and reduce duplicated  effort, the Elves
pair up and make  a big list of the section  assignments for each pair
(your puzzle input).

For example, consider the following list of section assignment pairs:
#+begin_example
2-4,6-8
2-3,4-5
5-7,7-9
2-8,3-7
6-6,4-6
2-6,4-8
#+end_example

For the first few pairs, this list means:
- Within the first pair of Elves,  the first Elf was assigned sections
  2-4  (sections 2,  3,  and 4),  while the  second  Elf was  assigned
  sections 6-8 (sections 6, 7, 8).
- The Elves in the second pair were each assigned two sections.
- The Elves in  the third pair were each assigned  three sections: one
  got sections 5, 6, and 7, while the other also got 7, plus 8 and 9.
  
This example list  uses single-digit section IDs to make  it easier to
draw; your actual  list might contain larger  numbers. Visually, these
pairs of section assignments look like this:
#+begin_example
.234.....  2-4
.....678.  6-8

.23......  2-3
...45....  4-5

....567..  5-7
......789  7-9

.2345678.  2-8
..34567..  3-7

.....6...  6-6
...456...  4-6

.23456...  2-6
...45678.  4-8
#+end_example

Some of  the pairs have  noticed that  one of their  assignments fully
contains the  other. For example, 2-8  fully contains 3-7, and  6-6 is
fully contained by  4-6. In pairs where one  assignment fully contains
the other, one Elf in the  pair would be exclusively cleaning sections
their partner will already be cleaning, so these seem like the most in
need of reconsideration. In this example, there are 2 such pairs.

In how many assignment pairs does one range fully contain the other?

#+begin_src fennel :session day04
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve [line]
  (let [[elf1 elf2] (aoc.string-split line ",")
        [f1 t1] (aoc.string-split elf1 "-")
        [f2 t2] (aoc.string-split elf2 "-")]
    (or (and (<= (aoc.int f1) (aoc.int f2)) (>= (aoc.int t1) (aoc.int t2)))
        (and (>= (aoc.int f1) (aoc.int f2)) (<= (aoc.int t1) (aoc.int t2))))))

(local input
       ["2-4,6-8"
        "2-3,4-5"
        "5-7,7-9"
        "2-8,3-7"
        "6-6,4-6"
        "2-6,4-8"])

(fn test-input [in]
  (assert
   (= 2 (length
         (lume.filter
          (lume.map in #(solve $))
          #(if $ true false))))))

(test-input input)

(fn real-input [in]
  (length
   (lume.filter
    (lume.map in #(solve $))
    #(if $ true false))))

(real-input (aoc.string-from "2022/04.inp"))
#+end_src

#+RESULTS:
: 536

* DONE Day 4.2
It  seems  like  there  is  still   quite  a  bit  of  duplicate  work
planned. Instead,  the Elves would  like to  know the number  of pairs
that overlap at all.

In the above example, the first  two pairs (2-4,6-8 and 2-3,4-5) don't
overlap, while  the remaining  four pairs (5-7,7-9,  2-8,3-7, 6-6,4-6,
and 2-6,4-8) do overlap:
- 5-7,7-9 overlaps in a single section, 7.
- 2-8,3-7 overlaps all of the sections 3 through 7.
- 6-6,4-6 overlaps in a single section, 6.
- 2-6,4-8 overlaps in sections 4, 5, and 6.

So,  in  this example,  the  number  of overlapping  assignment  pairs
is 4. In how many assignment pairs do the ranges overlap?

#+begin_src fennel :session day04
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve2 [line]
  (let [[elf1 elf2] (aoc.string-split line ",")
        [f1 t1] (aoc.string-split elf1 "-")
        [f2 t2] (aoc.string-split elf2 "-")]
    (or (and (<= (aoc.int f1) (aoc.int f2)) (>= (aoc.int t1) (aoc.int f2)))
        (and (<= (aoc.int f1) (aoc.int t2)) (>= (aoc.int t1) (aoc.int t2)))
        (and (<= (aoc.int f2) (aoc.int f1)) (>= (aoc.int t2) (aoc.int f1)))
        (and (<= (aoc.int f2) (aoc.int t1)) (>= (aoc.int t2) (aoc.int t1))))))

(fn test-input-2 [in]
  (assert
   (= 4 (length
         (lume.filter
          (lume.map in #(solve2 $))
          #(if $ true false))))))

(test-input-2 input)

(fn real-input-2 [in]
  (length
   (lume.filter
    (lume.map in #(solve2 $))
    #(if $ true false))))

(real-input-2 (aoc.string-from "2022/04.inp"))
#+end_src

#+RESULTS:
: 845

* DONE Day 5.1
The expedition  can depart  as soon  as the  final supplies  have been
unloaded  from the  ships. Supplies  are  stored in  stacks of  marked
crates, but  because the needed  supplies are buried under  many other
crates, the crates need to be rearranged.

The ship  has a  giant cargo  crane capable  of moving  crates between
stacks. To  ensure none of  the crates get  crushed or fall  over, the
crane operator  will rearrange them  in a series  of carefully-planned
steps. After the crates are rearranged,  the desired crates will be at
the top of each stack.

The  Elves don't  want to  interrupt  the crane  operator during  this
delicate procedure, but they forgot to ask her which crate will end up
where, and they want to be ready to unload them as soon as possible so
they can embark.

They do, however, have a drawing of the starting stacks of crates and
the rearrangement procedure (your puzzle input). For example:
#+begin_example
    [D]    
[N] [C]    
[Z] [M] [P]
 1   2   3 

move 1 from 2 to 1
move 3 from 1 to 3
move 2 from 2 to 1
move 1 from 1 to 2
#+end_example

In this  example, there are three  stacks of crates. Stack  1 contains
two crates: crate Z  is on the bottom, and crate N is  on top. Stack 2
contains three crates;  from bottom to top, they are  crates M, C, and
D. Finally, stack 3 contains a single crate, P.

Then,  the rearrangement  procedure  is  given. In  each  step of  the
procedure, a quantity of crates is moved from one stack to a different
stack. In  the first  step of the  above rearrangement  procedure, one
crate  is  moved   from  stack  2  to  stack  1,   resulting  in  this
configuration:
#+begin_example
[D]        
[N] [C]    
[Z] [M] [P]
 1   2   3 
#+end_example

In  the  second  step,  three  crates   are  moved  from  stack  1  to
stack 3.  Crates are moved  one at  a time, so  the first crate  to be
moved (D) ends up below the second and third crates:

#+begin_example
        [Z]
        [N]
    [C] [D]
    [M] [P]
 1   2   3
#+end_example

Then, both crates are moved from stack 2 to stack 1. Again, because
crates are moved one at a time, crate C ends up below crate M:
#+begin_example
        [Z]
        [N]
[M]     [D]
[C]     [P]
 1   2   3
#+end_example

Finally, one crate is moved from stack 1 to stack 2:
#+begin_example
        [Z]
        [N]
        [D]
[C] [M] [P]
 1   2   3
#+end_example

The Elves  just need to know  which crate will  end up on top  of each
stack; in this example, the top crates are C in stack 1, M in stack 2,
and Z in  stack 3, so you  should combine these together  and give the
Elves the message CMZ.

After the rearrangement procedure completes, what crate ends up on top
of each stack?

#+begin_src fennel :session day05
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(macro times [t body1 & rest-body]
  `(fcollect [i# 1 ,t 1]
     (do ,body1 ,(unpack rest-body))))

(fn test-input []
  (let [crates [["N" "Z"] ["D" "C" "M"] ["P"]]
        moves [[1 2 1] [3 1 3] [2 2 1] [1 1 2]]]
    (each [_ [n f t] (ipairs moves)]
      (times n (aoc.table-move 1 (. crates f) (. crates t))))
    (assert (= "CMZ"
               (aoc.table-tostring (. (aoc.table-transpose crates) 1))))))

(test-input)

(fn scan-crates [lines]
  (let [in (lume.map (aoc.table-range lines 1 8) #(aoc.string-toarray $))
        loc [2 6 10 14 18 22 26 30 34]
        res []]
    (each [i v (ipairs loc)]
      (table.insert res i
                    (lume.filter
                     [(. (. in 1) v) (. (. in 2) v) (. (. in 3) v)
                      (. (. in 4) v) (. (. in 5) v) (. (. in 6) v)
                      (. (. in 7) v) (. (. in 8) v)]
                     #(not= $ " "))))
    res))

(fn scan-moves [lines]
  (lume.map (aoc.table-range lines 11 (length lines))
            #(aoc.string-tonumarray $)))

(fn real-input [lines]
  (let [crates (scan-crates lines)
        moves (scan-moves lines)]
    (each [_ [n f t] (ipairs moves)]
      (times n (aoc.table-move 1 (. crates f) (. crates t))))
    (aoc.table-tostring (. (aoc.table-transpose crates) 1))))

(real-input (aoc.string-from "2022/05.inp"))
#+end_src

#+RESULTS:
: GFTNRBZPF

* DONE Day 5.2
As you  watch the  crane operator expertly  rearrange the  crates, you
notice the process isn't following your prediction.

Some mud was  covering the writing on  the side of the  crane, and you
quickly  wipe it  away. The  crane isn't  a CrateMover  9000 -  it's a
CrateMover 9001.

The CrateMover 9001 is notable for many new and exciting features: air
conditioning, leather seats,  an extra cup holder, and  the ability to
pick up and move multiple crates at once.

Again  considering the  example above,  the crates  begin in  the same
configuration:
#+begin_example
    [D]    
[N] [C]    
[Z] [M] [P]
 1   2   3 
#+end_example

Moving a  single crate  from stack 2  to stack 1  behaves the  same as
before:
#+begin_example
[D]        
[N] [C]    
[Z] [M] [P]
 1   2   3 
#+end_example

However, the  action of moving  three crates from  stack 1 to  stack 3
means that those three moved crates  stay in the same order, resulting
in this new configuration:
#+begin_example
        [D]
        [N]
    [C] [Z]
    [M] [P]
 1   2   3
#+end_example

Next, as both  crates are moved from  stack 2 to stack  1, they retain
their order as well:
#+begin_example
        [D]
        [N]
[C]     [Z]
[M]     [P]
 1   2   3
#+end_example

Finally, a single  crate is still moved  from stack 1 to  stack 2, but
now it's crate C that gets moved:
#+begin_example
        [D]
        [N]
        [Z]
[M] [C] [P]
 1   2   3
#+end_example

In this example,  the CrateMover 9001 has put the  crates in a totally
different order: MCD.

Before the  rearrangement process finishes, update  your simulation so
that the Elves know where they should  stand to be ready to unload the
final  supplies. After  the  rearrangement  procedure completes,  what
crate ends up on top of each stack?

#+begin_src fennel :session day05
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn test-input-p2 []
  (let [crates [["N" "Z"] ["D" "C" "M"] ["P"]]
        moves [[1 2 1] [3 1 3] [2 2 1] [1 1 2]]]
    (each [_ [n f t] (ipairs moves)]
      (aoc.table-move 1 (. crates f) (. crates t) n))
    (assert (= "MCD"
               (aoc.table-tostring (. (aoc.table-transpose crates) 1))))))

(test-input-p2)

(fn real-input-p2 [lines]
  (let [crates (scan-crates lines)
        moves (scan-moves lines)]
    (each [_ [n f t] (ipairs moves)]
      (aoc.table-move 1 (. crates f) (. crates t) n))
    (aoc.table-tostring (. (aoc.table-transpose crates) 1))))

(real-input-p2 (aoc.string-from "2022/05.inp"))

#+end_src

#+RESULTS:
: VRQWPDSGP

* DONE Day 6.1
The preparations are finally complete; you and the Elves leave camp on
foot and begin to make your way toward the star fruit grove.

As you move through the dense  undergrowth, one of the Elves gives you
a handheld  device. He says that  it has many fancy  features, but the
most important one to set up right now is the communication system.

However, because  he's heard  you have significant  experience dealing
with signal-based systems, he convinced  the other Elves that it would
be okay  to give you their  one malfunctioning device -  surely you'll
have no problem fixing it.

As if inspired by comedic timing, the device emits a few colorful
sparks.

To be able to communicate with the  Elves, the device needs to lock on
to their signal. The signal is a series of seemingly-random characters
that the device receives one at a time.

To fix the  communication system, you need to add  a subroutine to the
device that detects a start-of-packet marker in the datastream. In the
protocol being used  by the Elves, the start of  a packet is indicated
by a sequence of four characters that are all different.

The device will send your  subroutine a datastream buffer (your puzzle
input); your subroutine needs to identify the first position where the
four     most     recently     received    characters     were     all
different. Specifically, it  needs to report the  number of characters
from  the  beginning of  the  buffer  to the  end  of  the first  such
four-character marker.

For example, suppose you receive the following datastream buffer:

#+begin_example
mjqjpqmgbljsphdztnvjfqwrcgsmlb
#+end_example

After  the first  three  characters (mjq)  have  been received,  there
haven't been  enough characters received  yet to find the  marker. The
first  time a  marker could  occur is  after the  fourth character  is
received, making  the most recent  four characters mjqj. Because  j is
repeated, this isn't a marker.

The  first  time a  marker  appears  is  after the  seventh  character
arrives. Once  it does,  the last four  characters received  are jpqm,
which are all  different. In this case, your  subroutine should report
the  value 7,  because the  first start-of-packet  marker is  complete
after 7 characters have been processed.

Here are a few more examples:

- bvwbjplbgvbhsrlpgdmjqwftvncz: first marker after character 5
- nppdvjthqldpwncqszvftbrmjlhg: first marker after character 6
- nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg: first marker after character 10
- zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw: first marker after character 11

How  many   characters  need   to  be   processed  before   the  first
start-of-packet marker is detected?

#+begin_src fennel :session day06
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve [pos stream]
  (case (aoc.table-range stream (- pos 3) pos)
    (where [a b c d] (and (not= a b) (not= a c) (not= a d)
                          (not= b c) (not= b d) (not= c d))) pos
    [_a _b _c _d] (solve (+ 1 pos) stream)))

(fn test-input [expected input]
  (assert (= expected (solve 4 (aoc.string-toarray input)))))

(test-input 7 "mjqjpqmgbljsphdztnvjfqwrcgsmlb")
(test-input 5 "bvwbjplbgvbhsrlpgdmjqwftvncz")
(test-input 6 "nppdvjthqldpwncqszvftbrmjlhg")
(test-input 10 "nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg")
(test-input 11 "zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw")

(fn real-input [input]
  (solve 4 (aoc.string-toarray (. input 1))))

(real-input (aoc.string-from "2022/06.inp"))
#+end_src

#+RESULTS:
: 1538

* DONE Day 6.2
Your device's communication system is correctly detecting packets, but
still isn't working. It looks like it also needs to look for messages.

A  start-of-message  marker is  just  like  a start-of-packet  marker,
except it consists of 14 distinct characters rather than 4.

Here are the first positions of start-of-message markers for all of
the above examples:
- mjqjpqmgbljsphdztnvjfqwrcgsmlb: first marker after character 19
- bvwbjplbgvbhsrlpgdmjqwftvncz: first marker after character 23
- nppdvjthqldpwncqszvftbrmjlhg: first marker after character 23
- nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg: first marker after character 29
- zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw: first marker after character 26

How  many   characters  need   to  be   processed  before   the  first
start-of-message marker is detected?

#+begin_src fennel :session day06
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve2 [pos stream]
  (let [start-message (aoc.table-range stream (- pos 13) pos)]
    (if (= (length start-message)
           (length (lume.unique start-message))) pos
           (solve2 (+ 1 pos) stream))))

(fn test2-input [expected input]
  (assert (= expected (solve2 14 (aoc.string-toarray input)))))

(test2-input 19 "mjqjpqmgbljsphdztnvjfqwrcgsmlb")
(test2-input 23 "bvwbjplbgvbhsrlpgdmjqwftvncz")
(test2-input 23 "nppdvjthqldpwncqszvftbrmjlhg")
(test2-input 29 "nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg")
(test2-input 26 "zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw")

(fn real2-input [input]
  (solve2 14 (aoc.string-toarray (. input 1))))

(real2-input (aoc.string-from "2022/06.inp"))
#+end_src

#+RESULTS:
: 2315

* DONE Day 7.1
You  can hear  birds  chirping  and raindrops  hitting  leaves as  the
expedition  proceeds.  Occasionally,  you  can even  hear much  louder
sounds in the distance; how big do the animals get out here, anyway?

The device  the Elves gave  you has problems  with more than  just its
communication system. You try to run a system update:

#+begin_example
$ system-update --please --pretty-please-with-sugar-on-top
Error: No space left on device
#+end_example

Perhaps you can delete some files to make space for the update?

You browse around the filesystem to  assess the situation and save the
resulting terminal output (your puzzle input). For example:

#+begin_example
$ cd /
$ ls
dir a
14848514 b.txt
8504156 c.dat
dir d
$ cd a
$ ls
dir e
29116 f
2557 g
62596 h.lst
$ cd e
$ ls
584 i
$ cd ..
$ cd ..
$ cd d
$ ls
4060174 j
8033020 d.log
5626152 d.ext
7214296 k
#+end_example

The  filesystem  consists  of  a   tree  of  files  (plain  data)  and
directories  (which  can contain  other  directories  or files).   The
outermost  directory  is  called  /.   You  can  navigate  around  the
filesystem, moving into or out of directories and listing the contents
of the directory you're currently in.

Within the terminal  output, lines that begin with $  are commands you
executed, very much like some modern computers:
- cd  means change  directory.  This changes  which  directory is  the
  current directory, but the specific result depends on the argument:
  - cd x moves in one level: it looks in the current directory for the
    directory named x and makes it the current directory.
  - cd .. moves out one level: it finds the directory that contains
    the current directory, then makes that directory the current
    directory.
  - cd / switches the current directory to the outermost directory, /.
- ls  means list.  It  prints out  all of  the  files and  directories
  immediately contained by the current directory:
  - 123 abc means that the current directory contains a file named abc
    with size 123.
  - dir xyz means that the current directory contains a directory named xyz.

Given the commands and output in  the example above, you can determine
that the filesystem looks visually like this:

#+begin_example
- / (dir)
  - a (dir)
    - e (dir)
      - i (file, size=584)
    - f (file, size=29116)
    - g (file, size=2557)
    - h.lst (file, size=62596)
  - b.txt (file, size=14848514)
  - c.dat (file, size=8504156)
  - d (dir)
    - j (file, size=4060174)
    - d.log (file, size=8033020)
    - d.ext (file, size=5626152)
    - k (file, size=7214296)
#+end_example

Here, there are four directories: / (the outermost directory), a and d
(which  are in  /), and  e  (which is  in a).  These directories  also
contain files of various sizes.

Since the  disk is full,  your first step  should probably be  to find
directories that  are good  candidates for deletion.  To do  this, you
need to determine the total size  of each directory. The total size of
a directory is the sum of the sizes of the files it contains, directly
or  indirectly. (Directories  themselves do  not count  as having  any
intrinsic size.)

The total sizes of the directories above can be found as follows:
- The total size of directory e is 584 because it contains a single
  file i of size 584 and no other directories.
- The directory a has total size 94853 because it contains files f
  (size 29116), g (size 2557), and h.lst (size 62596), plus file i
  indirectly (a contains e which contains i).
- Directory d has total size 24933642.
- As the outermost directory, / contains every file. Its total size is
  48381165, the sum of the size of every file.
  
To begin,  find all of  the directories with a  total size of  at most
100000, then  calculate the sum of  their total sizes. In  the example
above, these directories are a and e;  the sum of their total sizes is
95437 (94853 + 584). (As in this example, this process can count files
more than once!)

Find all of the directories with a total size of at most 100000. What
is the sum of the total sizes of those directories?

#+begin_src fennel :session day07
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn push [xs x]
  (table.insert xs x)
  xs)

(fn pop [xs]
  (table.remove xs (length xs))
  xs)

(fn ncdu [fs pwd s]
  (let [name (table.concat pwd)
        size (tonumber s)]
    (tset fs name
          (+ (or (. fs name) 0) size)))
  (while (not= 0 (length (do (table.remove pwd) pwd)))
    (ncdu fs pwd s)))

(fn read [lines]
  (let [fs {}
        pwd []]
    (each [_ line (ipairs lines)]
      (let [tokens (aoc.string-split line " ")]
        (case tokens
          ["$" "cd" ".."] (pop pwd)
          ["$" "cd" "/"] (push pwd "/")
          ["$" "cd" x] (push pwd (.. x "/"))
          ["$" "ls"] nil
          ["dir" d] nil
          [s n] (ncdu fs (aoc.table-clone pwd) s))))
    fs))

(local test-1 ["$ cd /"
               "$ ls"
               "dir a"
               "14848514 b.txt"
               "8504156 c.dat"
               "dir d"
               "$ cd a"
               "$ ls"
               "dir e"
               "29116 f"
               "2557 g"
               "62596 h.lst"
               "$ cd e"
               "$ ls"
               "584 i"
               "$ cd .."
               "$ cd .."
               "$ cd d"
               "$ ls"
               "4060174 j"
               "8033020 d.log"
               "5626152 d.ext"
               "7214296 k"])

(fn size [fs s]
  (lume.reduce
   (lume.filter fs
                (fn [x] (<= x s)))
   (fn [a x] (+ a x))))

(fn path [fs p]
  (let [keys (lume.filter (lume.keys fs)
                          (fn [k] (aoc.string-starts-with k p)))]
    (aoc.fold (lume.map keys #(. fs $)))))

(fn test-input [input]
  (let [fs (read input)]
    (assert (= 95437 (size fs 100000)))))

(test-input test-1)

(fn real-input [input]
  (let [fs (read input)]
    (size fs 100000)))

(real-input (aoc.string-from "2022/07.inp"))

#+end_src

#+RESULTS:
: 1501149

* DONE Day 7.2
Now, you're ready to choose a directory to delete.

The total disk  space available to the filesystem is  70000000. To run
the update,  you need unused space  of at least 30000000.  You need to
find a directory you can delete that  will free up enough space to run
the update.

In the example  above, the total size of the  outermost directory (and
thus the total amount of used  space) is 48381165; this means that the
size of the unused space must currently be 21618835, which isn't quite
the  30000000 required  by  the update.  Therefore,  the update  still
requires a directory with total size of at least 8381165 to be deleted
before it can run.

To achieve this, you have the following options:
- Delete directory e, which would increase unused space by 584.
- Delete directory a, which would increase unused space by 94853.
- Delete directory d, which would increase unused space by 24933642.
- Delete directory /, which would increase unused space by 48381165.

Directories e and  a are both too small; deleting  them would not free
up enough  space. However, directories  d and  / are both  big enough!
Between  these,  choose  the  smallest:  d,  increasing  unused  space
by 24933642.

Find the  smallest directory  that, if deleted,  would free  up enough
space on the filesystem  to run the update. What is  the total size of
that directory?

#+begin_src fennel :session day07
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn make-enough-space [input]
  (let [fs (read input)
        required 30000000
        total 70000000
        available (- total (. fs "/"))
        minimum (- required available)]
    (aoc.table-min
     (lume.map
      (lume.filter
       (lume.keys fs)
       (fn [x] (>= (. fs x) minimum)))
      (fn [x] (. fs x))))))

(fn test-input-2 [input]
  (assert (= 24933642 (make-enough-space input))))

(test-input-2 test-1)

(fn real-input [input]
  (make-enough-space input))

(real-input (aoc.string-from "2022/07.inp"))
#+end_src

#+RESULTS:
: 10096985
